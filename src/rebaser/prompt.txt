I have a series of commits in a fork that introduced 8 files and modified three others. Most of these commits are me learning as I went and are not appropriate to be merged upstream in a pull request. Analyze the following commit history and come up with a detailed plan for rebasing the fork history including which commits to drop, reword, squash, etc. Return a list of git commands to perform in order to rebase the fork into as few commits as possible in preparation for the fork to be merged upstream in a pull request. Verify that this rebase commit will not result in any merge conflicts before sending your answer. 

Commit Hash: 66ba0899161e233767aaf42665508219017016de
Commit Message: Initial setup
Diff: (14 files changed)
File added: .github/workflows/auto-update.yml
@@ -0,0 +1,84 @@
+name: Auto-Update
+
+on:
+  schedule:
+    - cron: '0 0 * * 0'  # Every Sunday at midnight UTC
+  workflow_dispatch:
+
+env:
+  VERSION_FILE: version.txt
+  SETUP_FILE: setup.py
+  PYPROJECT: pyrproject.toml
+
+jobs:
+  sync:
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout your fork
+        uses: actions/checkout@v4
+        with:
+          ref: main
+          
+      - name: Read version number
+        id: version
+        run: |
+          CURRENT_VERSION=$(grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' "$VERSION_FILE" | head -n 1)
+          IFS='.' read -r  MAJOR MINOR PATCH <<< $CURRENT_VERSION
+          PATCH=$((PATCH + 1))
+          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
+          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
+          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
+          echo "major=$MAJOR" >> $GITHUB_OUTPUT
+          echo "minor=$MINOR" >> $GITHUB_OUTPUT
+
+      - name: Add upstream repo
+        run: |
+          git remote add upstream https://github.com/aerkalov/ebooklib
+          git fetch upstream
+          git merge upstream/main --no-edit
+
+      - name: Auto-increment version
+        id: increment_version
+        run: |
+          UPSTREAM_VERSION=$(grep -Eo '[0-9]+\.[0-9]+' "$VERSION_FILE" | head -n 1)
+          IFS='.' read -r UP_MAJOR UP_MINOR <<< $UPSTREAM_VERSION
+          if [ -n "$(git status --porcelain)" ]; then
+            if [[ UP_MAJOR == ${{ steps.version.outputs.major }} && UP_MINOR == ${{ steps.version.outputs.minor}} ]]; then
+              UPDATED_VERSION = ${{ steps.version.outputs.new_version }}
+            else
+              UPDATED_VERSION = "$UP_MAJOR.$UP_MINOR.0"
+            fi
+            sed -i "0,/$UPSTREAM_VERSION/s//$UPDATED_VERSION/" $VERSION_FILE $SETUP_FILE $PYPROJECT
+            git add $VERSION_FILE $SETUP_FILE $PYPROJECT
+            git commit -m "Auto-increment version to ${{ steps.version.outputs.new_version }}"
+          fi
+
+      - name: Update Python versions in setup file
+        run: |
+          python <<EOF
+          import re
+          supported_versions = ["3.6", "3.7", "3.8". "3.9", "3.10", "3.11", "3.12", "3.13"]
+          new_versions = [
+            f'         "Programming Language :: Python :: {version}"'
+            for version in supported versions
+          ]
+          setup_file = $SETUP_FILE
+          with open(setup_file, "r") as f:
+            original_text = f.read()
+          pattern = r'^\s*Programming Language :: Python :: [^\n]*(?:\n\s*Programming Language :: Python :: [^\n]*)*'
+          updated_text = re.sub(pattern, new_versions, original_text, flags=re.MULTILINE)
+          if updated_text == original_text:
+            exit(0)
+          with open(setup_file, "w") as f:
+            f.write(updated_text)
+          EOF
+          if [ -n "$(git status --porcelain)" ]; then
+            git add $SETUP_FILE
+            git commit -m "Update supported Python versions"
+          fi
+            
+      - name: Push changes to fork
+        run: |
+          git config --global user.name "github-actions[bot]"
+          git config --global user.email "github-actions[bot]@users.noreply.github.com"
+          git push origin main

File changed: VERSION.txt
@@ -1 +1 @@
-EbookLib 0.18
+EbookLib 0.18.1

ebooklib/__init__.py deleted
ebooklib/epub.py deleted
ebooklib/plugins/__init__.py deleted
ebooklib/plugins/base.py deleted
ebooklib/plugins/booktype.py deleted
ebooklib/plugins/sourcecode.py deleted
ebooklib/plugins/standard.py deleted
ebooklib/plugins/tidyhtml.py deleted
ebooklib/utils.py deleted
File added: pyproject.toml
@@ -0,0 +1,10 @@
+[project]
+name = "ebooklib-autoupdate"
+version = "0.18.1"
+description = "A self-updating fork of the Ebooklib library"
+readme = "README.md"
+requires-python = ">=3.6"
+dependencies = [
+    "lxml>=4.9.0",
+    "six>=1.0.0",
+]

File changed: setup.py
@@ -13,7 +13,7 @@ def read(path):
 
 setup(
     name = 'EbookLib',
-    version = '0.18',
+    version = '0.18.1',
     author = 'Aleksandar Erkalovic',
     author_email = 'aerkalov@gmail.com',
     packages = ['ebooklib', 'ebooklib.plugins'],
@@ -27,12 +27,13 @@ setup(
         "Development Status :: 4 - Beta",
         "Intended Audience :: Developers",
         "Operating System :: OS Independent",
-        "Programming Language :: Python :: 2.7",
-        "Programming Language :: Python :: 3.3",
-        "Programming Language :: Python :: 3.4",
-        "Programming Language :: Python :: 3.5",
         "Programming Language :: Python :: 3.6",
         "Programming Language :: Python :: 3.7",
+        "Programming Language :: Python :: 3.8",
+        "Programming Language :: Python :: 3.9",
+        "Programming Language :: Python :: 3.10",
+        "Programming Language :: Python :: 3.11",
+        "Programming Language :: Python :: 3.12",
         "Topic :: Software Development :: Libraries :: Python Modules"
     ],
     install_requires = [

File added: uv.lock

-------------------------

Commit Hash: 9ac447f1dee80c67df8faace9729e1f86864217c
Commit Message: Add permissions
Diff: (1 files changed)
File changed: .github/workflows/auto-update.yml
@@ -5,6 +5,10 @@ on:
     - cron: '0 0 * * 0'  # Every Sunday at midnight UTC
   workflow_dispatch:
 
+permissions:
+  id-token: write
+  contents: write
+
 env:
   VERSION_FILE: version.txt
   SETUP_FILE: setup.py

-------------------------

Commit Hash: c6634903ff97f8ae9ccd48ac42d70051dda5a1cc
Commit Message: Fix branch name main -> master
Diff: (1 files changed)
File changed: .github/workflows/auto-update.yml
@@ -18,10 +18,10 @@ jobs:
   sync:
     runs-on: ubuntu-latest
     steps:
-      - name: Checkout your fork
+      - name: Checkout
         uses: actions/checkout@v4
         with:
-          ref: main
+          ref: master
           
       - name: Read version number
         id: version
@@ -39,7 +39,7 @@ jobs:
         run: |
           git remote add upstream https://github.com/aerkalov/ebooklib
           git fetch upstream
-          git merge upstream/main --no-edit
+          git merge upstream/master --no-edit
 
       - name: Auto-increment version
         id: increment_version

-------------------------

Commit Hash: edccd8d5e5df14ce3c28c74b696b6427f5255622
Commit Message: merge
Diff: (1 files changed)
File changed: .github/workflows/auto-update.yml
@@ -5,6 +5,10 @@ on:
     - cron: '0 0 * * 0'  # Every Sunday at midnight UTC
   workflow_dispatch:
 
+permissions:
+  id-token: write
+  contents: write
+
 env:
   VERSION_FILE: version.txt
   SETUP_FILE: setup.py
@@ -14,10 +18,10 @@ jobs:
   sync:
     runs-on: ubuntu-latest
     steps:
-      - name: Checkout your fork
+      - name: Checkout
         uses: actions/checkout@v4
         with:
-          ref: main
+          ref: master
           
       - name: Read version number
         id: version
@@ -35,7 +39,7 @@ jobs:
         run: |
           git remote add upstream https://github.com/aerkalov/ebooklib
           git fetch upstream
-          git merge upstream/main --no-edit
+          git merge upstream/master --no-edit
 
       - name: Auto-increment version
         id: increment_version
@@ -81,4 +85,4 @@ jobs:
         run: |
           git config --global user.name "github-actions[bot]"
           git config --global user.email "github-actions[bot]@users.noreply.github.com"
-          git push origin main
+          git push origin main
\ No newline at end of file

-------------------------

Commit Hash: ab23fb039f9478d3fe445207120fccb822249063
Commit Message: M.github/workflows/auto-update.ymlerge branch 'master' of https://github.com/ProsePal/ebooklib-autoupdate
Diff: (0 files changed)
-------------------------

Commit Hash: 0f9c434d8e3a5f2c070c0dce36cef58b6ffe93dd
Commit Message: Fix merge issue with --allow-unrelated-histories
Diff: (1 files changed)
File changed: .github/workflows/auto-update.yml
@@ -39,7 +39,7 @@ jobs:
         run: |
           git remote add upstream https://github.com/aerkalov/ebooklib
           git fetch upstream
-          git merge upstream/master --no-edit
+          git merge upstream/master --allow-unrelated-histories --no-edit
 
       - name: Auto-increment version
         id: increment_version

-------------------------

Commit Hash: 1c9fd80c2a00740f8f401500493465f3cecff121
Commit Message: Fix empty ident. Move config up three steps
Diff: (1 files changed)
File changed: .github/workflows/auto-update.yml
@@ -39,6 +39,8 @@ jobs:
         run: |
           git remote add upstream https://github.com/aerkalov/ebooklib
           git fetch upstream
+          git config --global user.name "github-actions[bot]"
+          git config --global user.email "github-actions[bot]@users.noreply.github.com"
           git merge upstream/master --allow-unrelated-histories --no-edit
 
       - name: Auto-increment version
@@ -82,7 +84,4 @@ jobs:
           fi
             
       - name: Push changes to fork
-        run: |
-          git config --global user.name "github-actions[bot]"
-          git config --global user.email "github-actions[bot]@users.noreply.github.com"
-          git push origin main
\ No newline at end of file
+        run: git push origin main
\ No newline at end of file

-------------------------

Commit Hash: d076597b0aa9bb328ba39c032165d532145473ff
Commit Message: Fix merge conflics with --stategy-option theirs
Diff: (1 files changed)
File changed: .github/workflows/auto-update.yml
@@ -41,7 +41,7 @@ jobs:
           git fetch upstream
           git config --global user.name "github-actions[bot]"
           git config --global user.email "github-actions[bot]@users.noreply.github.com"
-          git merge upstream/master --allow-unrelated-histories --no-edit
+          git merge upstream/master --allow-unrelated-histories --strategy-option theirs
 
       - name: Auto-increment version
         id: increment_version

-------------------------

Commit Hash: f196c517eadf0cb918ff19b3656e0ff8b62d28ad
Commit Message: Fix env variables
Diff: (1 files changed)
File changed: .github/workflows/auto-update.yml
@@ -46,7 +46,7 @@ jobs:
       - name: Auto-increment version
         id: increment_version
         run: |
-          UPSTREAM_VERSION=$(grep -Eo '[0-9]+\.[0-9]+' "$VERSION_FILE" | head -n 1)
+          UPSTREAM_VERSION=$(grep -Eo '[0-9]+\.[0-9]+' "${{ env.VERSION_FILE }}" | head -n 1)
           IFS='.' read -r UP_MAJOR UP_MINOR <<< $UPSTREAM_VERSION
           if [ -n "$(git status --porcelain)" ]; then
             if [[ UP_MAJOR == ${{ steps.version.outputs.major }} && UP_MINOR == ${{ steps.version.outputs.minor}} ]]; then
@@ -54,8 +54,8 @@ jobs:
             else
               UPDATED_VERSION = "$UP_MAJOR.$UP_MINOR.0"
             fi
-            sed -i "0,/$UPSTREAM_VERSION/s//$UPDATED_VERSION/" $VERSION_FILE $SETUP_FILE $PYPROJECT
-            git add $VERSION_FILE $SETUP_FILE $PYPROJECT
+            sed -i "0,/$UPSTREAM_VERSION/s//$UPDATED_VERSION/" ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }} ${{ env.PYPROJECT }}
+            git add ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }} ${{ env.PYPROJECT }}
             git commit -m "Auto-increment version to ${{ steps.version.outputs.new_version }}"
           fi
 
@@ -68,7 +68,7 @@ jobs:
             f'         "Programming Language :: Python :: {version}"'
             for version in supported versions
           ]
-          setup_file = $SETUP_FILE
+          setup_file = ${{ env.SETUP_FILE }}
           with open(setup_file, "r") as f:
             original_text = f.read()
           pattern = r'^\s*Programming Language :: Python :: [^\n]*(?:\n\s*Programming Language :: Python :: [^\n]*)*'
@@ -79,7 +79,7 @@ jobs:
             f.write(updated_text)
           EOF
           if [ -n "$(git status --porcelain)" ]; then
-            git add $SETUP_FILE
+            git add ${{ env.SETUP_FILE }}
             git commit -m "Update supported Python versions"
           fi
             

-------------------------

Commit Hash: f767b257a31a6a3c411ec404e83f6332433eac1d
Commit Message: Fix version file name case sensitive
Diff: (1 files changed)
File changed: .github/workflows/auto-update.yml
@@ -10,7 +10,7 @@ permissions:
   contents: write
 
 env:
-  VERSION_FILE: version.txt
+  VERSION_FILE: VERSION.txt
   SETUP_FILE: setup.py
   PYPROJECT: pyrproject.toml
 

-------------------------

Commit Hash: 2aec6c1de59a1039fb6c3837c5ad11af4dc30e4f
Commit Message: Fix typo in python script period instead of comma in list
Diff: (1 files changed)
File changed: .github/workflows/auto-update.yml
@@ -63,7 +63,7 @@ jobs:
         run: |
           python <<EOF
           import re
-          supported_versions = ["3.6", "3.7", "3.8". "3.9", "3.10", "3.11", "3.12", "3.13"]
+          supported_versions = ["3.6", "3.7", "3.8", "3.9", "3.10", "3.11", "3.12", "3.13"]
           new_versions = [
             f'         "Programming Language :: Python :: {version}"'
             for version in supported versions

-------------------------

Commit Hash: a204f074a1e9dfafe96812654185cc9cbb7626c1
Commit Message: Fix typo in python script missing underscore in variable supported_versions
Diff: (1 files changed)
File changed: .github/workflows/auto-update.yml
@@ -63,16 +63,19 @@ jobs:
         run: |
           python <<EOF
           import re
-          supported_versions = ["3.6", "3.7", "3.8", "3.9", "3.10", "3.11", "3.12", "3.13"]
+          supported_versions = ["3.6", "3.7", "3.8", "3.9", "3.10", "3.11", "3.12"]
+          setup_file = "${{ env.SETUP_FILE }}"
+          with open(setup_file, "r") as f:
+            original_text = f.read()
+          old_version_nums = [version[4:].strip() for version in re.findall("Programming Language :: Python :: [^\n]", original_text]
+          if old_version_nums == supported_versions:
+            exit(0)
+          old_versions = r'^\s*Programming Language :: Python :: [^\n]*(?:\n\s*Programming Language :: Python :: [^\n]*)*'
           new_versions = [
             f'         "Programming Language :: Python :: {version}"'
-            for version in supported versions
+            for version in supported_versions
           ]
-          setup_file = ${{ env.SETUP_FILE }}
-          with open(setup_file, "r") as f:
-            original_text = f.read()
-          pattern = r'^\s*Programming Language :: Python :: [^\n]*(?:\n\s*Programming Language :: Python :: [^\n]*)*'
-          updated_text = re.sub(pattern, new_versions, original_text, flags=re.MULTILINE)
+          updated_text = re.sub(old_versions, new_versions, original_text, flags=re.MULTILINE)
           if updated_text == original_text:
             exit(0)
           with open(setup_file, "w") as f:

-------------------------

Commit Hash: 3db42396509ac3061e41d54f9efb82214b791801
Commit Message: Fix typo in python script missing end paranthesis re.finall
Diff: (1 files changed)
File changed: .github/workflows/auto-update.yml
@@ -67,14 +67,16 @@ jobs:
           setup_file = "${{ env.SETUP_FILE }}"
           with open(setup_file, "r") as f:
             original_text = f.read()
-          old_version_nums = [version[4:].strip() for version in re.findall("Programming Language :: Python :: [^\n]", original_text]
+          programming_line_stub = '"Programming Language :: Python :: '
+          programming_line = f'{programming_line_stub}[0-9.]+"'
+          old_version_nums = [version[4:].strip() for version in re.findall(programming_line, original_text)]
           if old_version_nums == supported_versions:
             exit(0)
-          old_versions = r'^\s*Programming Language :: Python :: [^\n]*(?:\n\s*Programming Language :: Python :: [^\n]*)*'
-          new_versions = [
-            f'         "Programming Language :: Python :: {version}"'
+          old_versions = rf'^\s*{programming_line}*(?:\n\s*{programming_line}*)*'
+          new_versions = "\n|.join(
+            f'         {programming_line_stub}{version}"'
             for version in supported_versions
-          ]
+          )
           updated_text = re.sub(old_versions, new_versions, original_text, flags=re.MULTILINE)
           if updated_text == original_text:
             exit(0)

-------------------------

Commit Hash: 1ce54eca58df01081b7c5562ba107ab1ee9fdc3f
Commit Message: Fix typo in Python script join
Diff: (1 files changed)
File changed: .github/workflows/auto-update.yml
@@ -73,7 +73,7 @@ jobs:
           if old_version_nums == supported_versions:
             exit(0)
           old_versions = rf'^\s*{programming_line}*(?:\n\s*{programming_line}*)*'
-          new_versions = "\n|.join(
+          new_versions = "\n".join(
             f'         {programming_line_stub}{version}"'
             for version in supported_versions
           )
@@ -89,4 +89,4 @@ jobs:
           fi
             
       - name: Push changes to fork
-        run: git push origin main
\ No newline at end of file
+        run: git push origin main

-------------------------

Commit Hash: 1bbe20de784d7711f9a70b4c2e7b227916e32c93
Commit Message: Revert to state before missing ebooklib directory
Diff: (13 files changed)
File changed: VERSION.txt
@@ -1 +1 @@
-EbookLib 0.18.1
+EbookLib 0.18

File added: ebooklib/__init__.py
File added: ebooklib/epub.py

File added: ebooklib/plugins/base.py
File added: ebooklib/plugins/booktype.py
File added: ebooklib/plugins/sourcecode.py
File added: ebooklib/plugins/standard.py
File added: ebooklib/plugins/tidyhtml.py
File added: ebooklib/utils.py
pyproject.toml deleted
File changed: setup.py
@@ -13,7 +13,7 @@ def read(path):
 
 setup(
     name = 'EbookLib',
-    version = '0.18.1',
+    version = '0.18',
     author = 'Aleksandar Erkalovic',
     author_email = 'aerkalov@gmail.com',
     packages = ['ebooklib', 'ebooklib.plugins'],
@@ -27,13 +27,12 @@ setup(
         "Development Status :: 4 - Beta",
         "Intended Audience :: Developers",
         "Operating System :: OS Independent",
+        "Programming Language :: Python :: 2.7",
+        "Programming Language :: Python :: 3.3",
+        "Programming Language :: Python :: 3.4",
+        "Programming Language :: Python :: 3.5",
         "Programming Language :: Python :: 3.6",
         "Programming Language :: Python :: 3.7",
-        "Programming Language :: Python :: 3.8",
-        "Programming Language :: Python :: 3.9",
-        "Programming Language :: Python :: 3.10",
-        "Programming Language :: Python :: 3.11",
-        "Programming Language :: Python :: 3.12",
         "Topic :: Software Development :: Libraries :: Python Modules"
     ],
     install_requires = [

uv.lock deleted
-------------------------

Commit Hash: c9ae9d8c7f56189d889e50ceba6f06ef5b15e230
Commit Message: Re-add uv management
Diff: (3 files changed)
File changed: .github/workflows/auto-update.yml
@@ -89,4 +89,4 @@ jobs:
           fi
             
       - name: Push changes to fork
-        run: git push origin main
+        run: git push origin main
\ No newline at end of file

File added: pyproject.toml
@@ -0,0 +1,10 @@
+[project]
+name = "ebooklib-autoupdate"
+version = "0.18.1"
+description = "Ebook library which can handle EPUB2/EPUB3"
+readme = "README.md"
+requires-python = ">=3.6"
+dependencies = [
+    "lxml>=4.9.0",
+    "six>=1.0.0",
+]

File added: uv.lock

-------------------------

Commit Hash: f39d61cf3abc82a8d36fdcc3ef4e0d18992e8281
Commit Message: Rewrite workflow
Diff: (1 files changed)
File changed: .github/workflows/auto-update.yml
@@ -6,13 +6,12 @@ on:
   workflow_dispatch:
 
 permissions:
-  id-token: write
   contents: write
 
 env:
   VERSION_FILE: VERSION.txt
   SETUP_FILE: setup.py
-  PYPROJECT: pyrproject.toml
+  PYPROJECT_FILE: pyproject.toml
 
 jobs:
   sync:
@@ -20,73 +19,107 @@ jobs:
     steps:
       - name: Checkout
         uses: actions/checkout@v4
-        with:
-          ref: master
-          
-      - name: Read version number
-        id: version
-        run: |
-          CURRENT_VERSION=$(grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' "$VERSION_FILE" | head -n 1)
-          IFS='.' read -r  MAJOR MINOR PATCH <<< $CURRENT_VERSION
-          PATCH=$((PATCH + 1))
-          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
-          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
-          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
-          echo "major=$MAJOR" >> $GITHUB_OUTPUT
-          echo "minor=$MINOR" >> $GITHUB_OUTPUT
 
       - name: Add upstream repo
         run: |
           git remote add upstream https://github.com/aerkalov/ebooklib
           git fetch upstream
+
+      - name: Read fork version and setup hash
+        id: fork_state
+        run: |
+          CURRENT_VERSION=$(grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' "${{ env.VERSION_FILE }}"
+          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
+
+      - name: Add GitHub Action Bot
+        run: |
           git config --global user.name "github-actions[bot]"
           git config --global user.email "github-actions[bot]@users.noreply.github.com"
-          git merge upstream/master --allow-unrelated-histories --strategy-option theirs
 
-      - name: Auto-increment version
-        id: increment_version
+      - name: Check if upstream has changes
+        id: upstream_changes
         run: |
-          UPSTREAM_VERSION=$(grep -Eo '[0-9]+\.[0-9]+' "${{ env.VERSION_FILE }}" | head -n 1)
-          IFS='.' read -r UP_MAJOR UP_MINOR <<< $UPSTREAM_VERSION
-          if [ -n "$(git status --porcelain)" ]; then
-            if [[ UP_MAJOR == ${{ steps.version.outputs.major }} && UP_MINOR == ${{ steps.version.outputs.minor}} ]]; then
-              UPDATED_VERSION = ${{ steps.version.outputs.new_version }}
+          VERSION_TIMESTAMP=$(git log -1 --format=%at -- ${{ env.VERSION_FILE }})
+          UPSTREAM_SETUP_TIMESTAMP=$(git log upstream/master -1 --format=%at -- ${{ env.SETUP_FILE }})
+          if [[ $(git log upstream/master -1 --format=%at) -gt $VERSION_TIMESTAMP ]]; then
+            echo "merge_needed=true" >> $GITHUB_OUTPUT
+          else
+            echo "merge_needed=false" >> $GITHUB_OUTPUT
+          fi
+          if [[ $UPSTREAM_SETUP_TIMESTAMP -gt $VERSION_TIMESTAMP ]]; then
+            echo "update_setup=true" >> $GITHUB_OUTPUT
+          else
+            echo "update_setup=false" >> $GITHUB_OUTPUT
+          fi
+
+      - name: Merge upstream changes
+        if: steps.upstream_changes.outputs.merge_needed == 'true'
+        run: |
+          {
+            echo "${{ env.VERSION_FILE }} merge=theirs"
+            if [[ "${{ steps.upstream_changes.outputs.update_setup }}" == "true" ]]; then
+              echo "${{ env.SETUP_FILE }} merge=theirs"
             else
-              UPDATED_VERSION = "$UP_MAJOR.$UP_MINOR.0"
+              echo "${{ env.SETUP_FILE }} merge=ours"
             fi
-            sed -i "0,/$UPSTREAM_VERSION/s//$UPDATED_VERSION/" ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }} ${{ env.PYPROJECT }}
-            git add ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }} ${{ env.PYPROJECT }}
-            git commit -m "Auto-increment version to ${{ steps.version.outputs.new_version }}"
+          } > .gitattributes
+          git merge upstream/master --no-edit
+
+      - name: Increment version
+        if: steps.upstream_changes.outputs.merge_needed == 'true'
+        run: |
+          UPSTREAM_VERSION=$(grep -Eo '[0-9]+\.[0-9]+' "${{ env.VERSION_FILE }}")
+          IFS='.' read -r UPSTREAM_MAJOR UPSTREAM._MINOR <<< "$UPSTREAM_VERSION"
+          CURRENT_VERSION="${{ steps.fork_state.outputs.current_version }}"
+          IFS='.' read -r CURRENT_MAJOR CURRENT_MINOR PATCH <<< "$CURRENT_VERSION"
+          if [[ $UPSTREAM_MAJOR == $CURRENT_MAJOR && $UPSTREAM_MINOR == $CURRENT_MINOR ]]; then
+            PATCH=$(($PATCH + 1))
+            UPDATED_VERSION="$CURRENT_MAJOR.$CURRENT_MINOR.$PATCH"
+          else
+            UPDATED_VERSION="$UPSTREAM_MAJOR.$UPSTREAM_MINOR.0"
           fi
+          sed -i "0,/$UPSTREAM_VERSION/s//$UPDATED_VERSION/" ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }}
+          sed -i "0,/$CURRENT_VERSION/s//$UPDATED_VERSION" ${{ env.PYPROJECT_FILE }}
+          git add ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }} ${{ env.PYPROJECT_FILE }}
+          git commit -m "Auto-increment version to $UPDATED_VERSION"
 
-      - name: Update Python versions in setup file
+      - name: Update supported Python versions in setup.py
+        if: steps.upstream_changes.outputs.update_setup == 'true'
         run: |
           python <<EOF
           import re
           supported_versions = ["3.6", "3.7", "3.8", "3.9", "3.10", "3.11", "3.12"]
           setup_file = "${{ env.SETUP_FILE }}"
           with open(setup_file, "r") as f:
-            original_text = f.read()
+              original_text = f.read()
           programming_line_stub = '"Programming Language :: Python :: '
           programming_line = f'{programming_line_stub}[0-9.]+"'
-          old_version_nums = [version[4:].strip() for version in re.findall(programming_line, original_text)]
-          if old_version_nums == supported_versions:
-            exit(0)
-          old_versions = rf'^\s*{programming_line}*(?:\n\s*{programming_line}*)*'
+          existing_versions = sorted(version[4:].strip() for version in re.findall(programming_line, original_text))
+          if existing_versions == supported_versions:
+              exit(0)
+          old_versions = rf'^\s*{programming_line}*(?:\n,\s*{programming_line})'
           new_versions = "\n".join(
-            f'         {programming_line_stub}{version}"'
+            f'         {programming_line_stub}{version},"'
             for version in supported_versions
           )
-          updated_text = re.sub(old_versions, new_versions, original_text, flags=re.MULTILINE)
-          if updated_text == original_text:
-            exit(0)
-          with open(setup_file, "w") as f:
-            f.write(updated_text)
+          updated_text = re.sub(old_versions, new_versions.rstrip(","), original_text, flags=re.MULTILINE)
+          if updated_text != original_text:
+              with open(setup_file, "w") as f:
+                  f.write(updated_text)
           EOF
           if [ -n "$(git status --porcelain)" ]; then
             git add ${{ env.SETUP_FILE }}
             git commit -m "Update supported Python versions"
           fi
-            
+
       - name: Push changes to fork
-        run: git push origin main
\ No newline at end of file
+        if: steps.upstream_changes.outputs.merge_needed == 'true'
+        run: git push origin master
+
+      - name: Sync new branches
+        run: |
+          NEW_BRANCHES=$(git branch -r | grep "upstream/" | grep -v -f <(git branch -r | grep "origin/" | sed 's/origin/upstream/') | grep -v "HEAD" | sed 's/upstream\///')
+          for BRANCH in $NEW_BRANCHES; do
+            git checkout -b "$BRANCH" "upstream/$BRANCH"
+            git push -u origin "$BRANCH"
+          done

-------------------------

Commit Hash: e5b1ec491bd7409eca6fc5eb1a63cef34c713aad
Commit Message: Update setup.py
Diff: (1 files changed)
File changed: setup.py
@@ -19,20 +19,21 @@ setup(
     packages = ['ebooklib', 'ebooklib.plugins'],
     url = 'https://github.com/aerkalov/ebooklib',
     license = 'GNU Affero General Public License',
-    description = 'Ebook library which can handle EPUB2/EPUB3 and Kindle format',
+    description = 'Ebook library which can handle EPUB2/EPUB3 format',
     long_description = read('README.md'),
     long_description_content_type = 'text/markdown',
-    keywords = ['ebook', 'epub', 'kindle'],
+    keywords = ['ebook', 'epub'],
     classifiers = [
         "Development Status :: 4 - Beta",
         "Intended Audience :: Developers",
         "Operating System :: OS Independent",
-        "Programming Language :: Python :: 2.7",
-        "Programming Language :: Python :: 3.3",
-        "Programming Language :: Python :: 3.4",
-        "Programming Language :: Python :: 3.5",
         "Programming Language :: Python :: 3.6",
         "Programming Language :: Python :: 3.7",
+        "Programming Language :: Python :: 3.8",
+        "Programming Language :: Python :: 3.9",
+        "Programming Language :: Python :: 3.10",
+        "Programming Language :: Python :: 3.11",
+        "Programming Language :: Python :: 3.12",
         "Topic :: Software Development :: Libraries :: Python Modules"
     ],
     install_requires = [

-------------------------

Commit Hash: 020c9e78e1cb22b1f26a5e08136bf24e987976b8
Commit Message: Update version number
Diff: (1 files changed)
File changed: setup.py
@@ -13,7 +13,7 @@ def read(path):
 
 setup(
     name = 'EbookLib',
-    version = '0.18',
+    version = '0.18.1',
     author = 'Aleksandar Erkalovic',
     author_email = 'aerkalov@gmail.com',
     packages = ['ebooklib', 'ebooklib.plugins'],

-------------------------

Commit Hash: 87eb2b4ea30746d6b684e53eed154b936273c2a8
Commit Message: Update version number
Diff: (1 files changed)
File changed: VERSION.txt
@@ -1 +1 @@
-EbookLib 0.18
+EbookLib 0.18.1

-------------------------

Commit Hash: ab46c4d249a395183a43677d9b8ff625b0fe031b
Commit Message: Update Python script to remove kindle references
Diff: (1 files changed)
File changed: .github/workflows/auto-update.yml
@@ -22,7 +22,7 @@ jobs:
 
       - name: Add upstream repo
         run: |
-          git remote add upstream https://github.com/aerkalov/ebooklib
+          git remote add upstream https://github.com/aerkalov/ebooklib || echo "Upstream already added"
           git fetch upstream
 
       - name: Read fork version and setup hash
@@ -32,11 +32,11 @@ jobs:
           echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
 
       - name: Add GitHub Action Bot
-        run: |
-          git config --global user.name "github-actions[bot]"
-          git config --global user.email "github-actions[bot]@users.noreply.github.com"
+         run: |
+           git config --global user.name "github-actions[bot]"
+           git config --global user.email "github-actions[bot]@users.noreply.github.com"
 
-      - name: Check if upstream has changes
+       - name: Check if upstream has changes
         id: upstream_changes
         run: |
           VERSION_TIMESTAMP=$(git log -1 --format=%at -- ${{ env.VERSION_FILE }})
@@ -75,13 +75,13 @@ jobs:
           if [[ $UPSTREAM_MAJOR == $CURRENT_MAJOR && $UPSTREAM_MINOR == $CURRENT_MINOR ]]; then
             PATCH=$(($PATCH + 1))
             UPDATED_VERSION="$CURRENT_MAJOR.$CURRENT_MINOR.$PATCH"
-          else
-            UPDATED_VERSION="$UPSTREAM_MAJOR.$UPSTREAM_MINOR.0"
-          fi
-          sed -i "0,/$UPSTREAM_VERSION/s//$UPDATED_VERSION/" ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }}
-          sed -i "0,/$CURRENT_VERSION/s//$UPDATED_VERSION" ${{ env.PYPROJECT_FILE }}
-          git add ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }} ${{ env.PYPROJECT_FILE }}
-          git commit -m "Auto-increment version to $UPDATED_VERSION"
+            else
+              UPDATED_VERSION="$UPSTREAM_MAJOR.$UPSTREAM_MINOR.0"
+            fi
+            sed -i "0,/$UPSTREAM_VERSION/s//$UPDATED_VERSION/" ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }}
+            sed -i "0,/$CURRENT_VERSION/s//$UPDATED_VERSION" ${{ env.PYPROJECT_FILE }}
+            git add ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }} ${{ env.PYPROJECT_FILE }}
+            git commit -m "Auto-increment version to $UPDATED_VERSION"
 
       - name: Update supported Python versions in setup.py
         if: steps.upstream_changes.outputs.update_setup == 'true'
@@ -91,26 +91,25 @@ jobs:
           supported_versions = ["3.6", "3.7", "3.8", "3.9", "3.10", "3.11", "3.12"]
           setup_file = "${{ env.SETUP_FILE }}"
           with open(setup_file, "r") as f:
-              original_text = f.read()
+            original_text = f.read()
+          text = re.sub("and kindle ", "", original_text)
+          allowed_keywords = r"Keywords = ['ebook', 'epub']"
+          keyword_pattern = r"Keywords = [(?:'\w+',\s?)*'\w+']"
+          corrected_text = re.sub(keyword_pattern, allowed_keywords, text)
           programming_line_stub = '"Programming Language :: Python :: '
-          programming_line = f'{programming_line_stub}[0-9.]+"'
-          existing_versions = sorted(version[4:].strip() for version in re.findall(programming_line, original_text))
-          if existing_versions == supported_versions:
-              exit(0)
-          old_versions = rf'^\s*{programming_line}*(?:\n,\s*{programming_line})'
+          programming_line = f'{programming_line_stub}[0-9.]+,"'
+          existing_versions = sorted(version[4:].strip() for version in re.findall(programming_line, corrected_text))
+          old_versions = rf'^\s*{programming_line}*(?:\n\s*{programming_line})*'
           new_versions = "\n".join(
             f'         {programming_line_stub}{version},"'
             for version in supported_versions
           )
-          updated_text = re.sub(old_versions, new_versions.rstrip(","), original_text, flags=re.MULTILINE)
-          if updated_text != original_text:
-              with open(setup_file, "w") as f:
-                  f.write(updated_text)
+          updated_text = re.sub(old_versions, new_versions, corrected_text, flags=re.MULTILINE)
+          with open(setup_file, "w") as f:
+            f.write(updated_text)
           EOF
-          if [ -n "$(git status --porcelain)" ]; then
-            git add ${{ env.SETUP_FILE }}
-            git commit -m "Update supported Python versions"
-          fi
+          git add ${{ env.SETUP_FILE }}
+          git commit -m "Update supported Python versions"
 
       - name: Push changes to fork
         if: steps.upstream_changes.outputs.merge_needed == 'true'
@@ -119,7 +118,7 @@ jobs:
       - name: Sync new branches
         run: |
           NEW_BRANCHES=$(git branch -r | grep "upstream/" | grep -v -f <(git branch -r | grep "origin/" | sed 's/origin/upstream/') | grep -v "HEAD" | sed 's/upstream\///')
-          for BRANCH in $NEW_BRANCHES; do
-            git checkout -b "$BRANCH" "upstream/$BRANCH"
-            git push -u origin "$BRANCH"
-          done
+         for BRANCH in $NEW_BRANCHES; do
+           git checkout -b "$BRANCH" "upstream/$BRANCH"
+           git push -u origin "$BRANCH"
+         done

-------------------------

Commit Hash: d93c9db2df5ee683c0873a572aa6a1d8a181844c
Commit Message: Fix indentation
Diff: (1 files changed)
File changed: .github/workflows/auto-update.yml
@@ -32,11 +32,11 @@ jobs:
           echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
 
       - name: Add GitHub Action Bot
-         run: |
-           git config --global user.name "github-actions[bot]"
-           git config --global user.email "github-actions[bot]@users.noreply.github.com"
+        run: |
+          git config --global user.name "github-actions[bot]"
+          git config --global user.email "github-actions[bot]@users.noreply.github.com"
 
-       - name: Check if upstream has changes
+      - name: Check if upstream has changes
         id: upstream_changes
         run: |
           VERSION_TIMESTAMP=$(git log -1 --format=%at -- ${{ env.VERSION_FILE }})
@@ -75,13 +75,13 @@ jobs:
           if [[ $UPSTREAM_MAJOR == $CURRENT_MAJOR && $UPSTREAM_MINOR == $CURRENT_MINOR ]]; then
             PATCH=$(($PATCH + 1))
             UPDATED_VERSION="$CURRENT_MAJOR.$CURRENT_MINOR.$PATCH"
-            else
-              UPDATED_VERSION="$UPSTREAM_MAJOR.$UPSTREAM_MINOR.0"
-            fi
-            sed -i "0,/$UPSTREAM_VERSION/s//$UPDATED_VERSION/" ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }}
-            sed -i "0,/$CURRENT_VERSION/s//$UPDATED_VERSION" ${{ env.PYPROJECT_FILE }}
-            git add ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }} ${{ env.PYPROJECT_FILE }}
-            git commit -m "Auto-increment version to $UPDATED_VERSION"
+          else
+            UPDATED_VERSION="$UPSTREAM_MAJOR.$UPSTREAM_MINOR.0"
+          fi
+          sed -i "0,/$UPSTREAM_VERSION/s//$UPDATED_VERSION/" ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }}
+          sed -i "0,/$CURRENT_VERSION/s//$UPDATED_VERSION" ${{ env.PYPROJECT_FILE }}
+          git add ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }} ${{ env.PYPROJECT_FILE }}
+          git commit -m "Auto-increment version to $UPDATED_VERSION"
 
       - name: Update supported Python versions in setup.py
         if: steps.upstream_changes.outputs.update_setup == 'true'
@@ -118,7 +118,7 @@ jobs:
       - name: Sync new branches
         run: |
           NEW_BRANCHES=$(git branch -r | grep "upstream/" | grep -v -f <(git branch -r | grep "origin/" | sed 's/origin/upstream/') | grep -v "HEAD" | sed 's/upstream\///')
-         for BRANCH in $NEW_BRANCHES; do
-           git checkout -b "$BRANCH" "upstream/$BRANCH"
-           git push -u origin "$BRANCH"
-         done
+          for BRANCH in $NEW_BRANCHES; do
+            git checkout -b "$BRANCH" "upstream/$BRANCH"
+            git push -u origin "$BRANCH"
+          done

-------------------------

Commit Hash: b0d19b6624663b4e2366c4c364d68369ad9de71f
Commit Message: Fix missing parenthesis
Diff: (1 files changed)
File changed: .github/workflows/auto-update.yml
@@ -28,7 +28,7 @@ jobs:
       - name: Read fork version and setup hash
         id: fork_state
         run: |
-          CURRENT_VERSION=$(grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' "${{ env.VERSION_FILE }}"
+          CURRENT_VERSION=$(grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' "${{ env.VERSION_FILE }}")
           echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
 
       - name: Add GitHub Action Bot

-------------------------

Commit Hash: 9037dc9de573d5d9778b4a0ab23c3a7eb08af684
Commit Message: Fix branch sync
Diff: (1 files changed)
File changed: .github/workflows/auto-update.yml
@@ -117,7 +117,9 @@ jobs:
 
       - name: Sync new branches
         run: |
-          NEW_BRANCHES=$(git branch -r | grep "upstream/" | grep -v -f <(git branch -r | grep "origin/" | sed 's/origin/upstream/') | grep -v "HEAD" | sed 's/upstream\///')
+          NEW_BRANCHES=$(comm -23 \
+            <(git branch -r | grep "upstream/" | grep -v "HEAD" | sed 's/  upstream\///' | sort) \
+            <(git branch -r | grep "origin/" | sed 's/  origin\///' | sort))
           for BRANCH in $NEW_BRANCHES; do
             git checkout -b "$BRANCH" "upstream/$BRANCH"
             git push -u origin "$BRANCH"

-------------------------

Commit Hash: 27dc20dfd0be45920bbb1b465248b621b4798136
Commit Message: Update lock file
Diff: (1 files changed)
File changed: uv.lock

-------------------------

Commit Hash: 54a885c59ce9e6749da55a5db60a5bdb4c10661a
Commit Message: Add .vscode directory
Diff: (1 files changed)
File changed: .gitignore
@@ -116,3 +116,6 @@ venv.bak/
 
 ### JetBrains template
 .idea/
+
+# VSCode
+.vscode/
\ No newline at end of file

-------------------------

Commit Hash: dce908e6e268702ac656d3cd74a6ce24fa7a5335
Commit Message: Add build & publish
Diff: (1 files changed)
File changed: .github/workflows/auto-update.yml
@@ -7,6 +7,7 @@ on:
 
 permissions:
   contents: write
+  id-token: write
 
 env:
   VERSION_FILE: VERSION.txt
@@ -14,7 +15,7 @@ env:
   PYPROJECT_FILE: pyproject.toml
 
 jobs:
-  sync:
+  update:
     runs-on: ubuntu-latest
     steps:
       - name: Checkout
@@ -42,9 +43,9 @@ jobs:
           VERSION_TIMESTAMP=$(git log -1 --format=%at -- ${{ env.VERSION_FILE }})
           UPSTREAM_SETUP_TIMESTAMP=$(git log upstream/master -1 --format=%at -- ${{ env.SETUP_FILE }})
           if [[ $(git log upstream/master -1 --format=%at) -gt $VERSION_TIMESTAMP ]]; then
-            echo "merge_needed=true" >> $GITHUB_OUTPUT
+            echo "updated_version=true" >> $GITHUB_OUTPUT
           else
-            echo "merge_needed=false" >> $GITHUB_OUTPUT
+            echo "updated_version=false" >> $GITHUB_OUTPUT
           fi
           if [[ $UPSTREAM_SETUP_TIMESTAMP -gt $VERSION_TIMESTAMP ]]; then
             echo "update_setup=true" >> $GITHUB_OUTPUT
@@ -53,7 +54,7 @@ jobs:
           fi
 
       - name: Merge upstream changes
-        if: steps.upstream_changes.outputs.merge_needed == 'true'
+        if: steps.upstream_changes.outputs.updated_version == 'true'
         run: |
           {
             echo "${{ env.VERSION_FILE }} merge=theirs"
@@ -66,22 +67,23 @@ jobs:
           git merge upstream/master --no-edit
 
       - name: Increment version
-        if: steps.upstream_changes.outputs.merge_needed == 'true'
+        id: version
+        if: steps.upstream_changes.outputs.updated_version == 'true'
         run: |
           UPSTREAM_VERSION=$(grep -Eo '[0-9]+\.[0-9]+' "${{ env.VERSION_FILE }}")
-          IFS='.' read -r UPSTREAM_MAJOR UPSTREAM._MINOR <<< "$UPSTREAM_VERSION"
+          IFS='.' read -r UPSTREAM_MAJOR UPSTREAM_MINOR <<< "$UPSTREAM_VERSION"
           CURRENT_VERSION="${{ steps.fork_state.outputs.current_version }}"
           IFS='.' read -r CURRENT_MAJOR CURRENT_MINOR PATCH <<< "$CURRENT_VERSION"
           if [[ $UPSTREAM_MAJOR == $CURRENT_MAJOR && $UPSTREAM_MINOR == $CURRENT_MINOR ]]; then
             PATCH=$(($PATCH + 1))
-            UPDATED_VERSION="$CURRENT_MAJOR.$CURRENT_MINOR.$PATCH"
+            NEW_VERSION="$CURRENT_MAJOR.$CURRENT_MINOR.$PATCH"
           else
-            UPDATED_VERSION="$UPSTREAM_MAJOR.$UPSTREAM_MINOR.0"
+            NEW_VERSION="$UPSTREAM_MAJOR.$UPSTREAM_MINOR.0"
           fi
-          sed -i "0,/$UPSTREAM_VERSION/s//$UPDATED_VERSION/" ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }}
-          sed -i "0,/$CURRENT_VERSION/s//$UPDATED_VERSION" ${{ env.PYPROJECT_FILE }}
+          sed -i "0,/$UPSTREAM_VERSION/s//$NEW_VERSION/" ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }}
+          sed -i "0,/$CURRENT_VERSION/s//$NEW_VERSION" ${{ env.PYPROJECT_FILE }}
           git add ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }} ${{ env.PYPROJECT_FILE }}
-          git commit -m "Auto-increment version to $UPDATED_VERSION"
+          git commit -m "Auto-increment version to $NEW_VERSION"
 
       - name: Update supported Python versions in setup.py
         if: steps.upstream_changes.outputs.update_setup == 'true'
@@ -104,23 +106,41 @@ jobs:
             f'         {programming_line_stub}{version},"'
             for version in supported_versions
           )
-          updated_text = re.sub(old_versions, new_versions, corrected_text, flags=re.MULTILINE)
+          new_version_text = re.sub(old_versions, new_versions, corrected_text, flags=re.MULTILINE)
           with open(setup_file, "w") as f:
-            f.write(updated_text)
+            f.write(new_version_text)
           EOF
           git add ${{ env.SETUP_FILE }}
           git commit -m "Update supported Python versions"
 
       - name: Push changes to fork
-        if: steps.upstream_changes.outputs.merge_needed == 'true'
+        if: steps.upstream_changes.outputs.updated_version == 'true'
         run: git push origin master
 
+      - name: Install uv
+        if: steps.upstream_changes.outputs.updated_version == 'true'
+        uses: astral-sh/setup-uv@v5
+        with:
+          enable-cache: true
+
+      - name: Build and publish
+        if: steps.upstream_changes.outputs.updated_version == 'true'
+        run: |
+          uv build
+          uv publish
+
       - name: Sync new branches
         run: |
-          NEW_BRANCHES=$(comm -23 \
-            <(git branch -r | grep "upstream/" | grep -v "HEAD" | sed 's/  upstream\///' | sort) \
-            <(git branch -r | grep "origin/" | sed 's/  origin\///' | sort))
-          for BRANCH in $NEW_BRANCHES; do
-            git checkout -b "$BRANCH" "upstream/$BRANCH"
-            git push -u origin "$BRANCH"
-          done
+          git fetch --all
+          for BRANCH in $(git branch -r | grep "upstream/" | grep -v "HEAD" | sed 's/upstream\///'); do
+            if [ "$BRANCH" == "master" ]; then
+              continue
+            fi
+            if ! git show-ref --verify --quiet "refs/heads/$BRANCH"; then
+              git branch "$BRANCH" "upstream/$BRANCH"
+            else
+              git checkout "$BRANCH"
+              git merge -s recursive -X theirs "upstream/$BRANCH" --no-edit
+            fi
+            git push -f origin "$BRANCH"
+          done
\ No newline at end of file

-------------------------

Commit Hash: a34047dbba5dd4f3f39e26d42321bd293d8a8f5d
Commit Message: Update readme
Diff: (2 files changed)
File changed: .github/workflows/auto-update.yml
@@ -13,6 +13,7 @@ env:
   VERSION_FILE: VERSION.txt
   SETUP_FILE: setup.py
   PYPROJECT_FILE: pyproject.toml
+  README_FILE: README.md
 
 jobs:
   update:
@@ -26,7 +27,7 @@ jobs:
           git remote add upstream https://github.com/aerkalov/ebooklib || echo "Upstream already added"
           git fetch upstream
 
-      - name: Read fork version and setup hash
+      - name: Read fork version
         id: fork_state
         run: |
           CURRENT_VERSION=$(grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' "${{ env.VERSION_FILE }}")
@@ -42,6 +43,7 @@ jobs:
         run: |
           VERSION_TIMESTAMP=$(git log -1 --format=%at -- ${{ env.VERSION_FILE }})
           UPSTREAM_SETUP_TIMESTAMP=$(git log upstream/master -1 --format=%at -- ${{ env.SETUP_FILE }})
+          UPSTREAM_README_TIMESTAMP=$(git log upstream/master -1 --format=%at -- ${{ env.README_FILE }})
           if [[ $(git log upstream/master -1 --format=%at) -gt $VERSION_TIMESTAMP ]]; then
             echo "updated_version=true" >> $GITHUB_OUTPUT
           else
@@ -52,6 +54,11 @@ jobs:
           else
             echo "update_setup=false" >> $GITHUB_OUTPUT
           fi
+          if [[ $UPSTREAM_README_TIMESTAMP -gt $VERSION_TIMESTAMP ]]; then
+            echo "update_readme=true" >> $GITHUB_OUTPUT
+          else
+            echo "update_readme=false" >> $GITHUB_OUTPUT
+          fi
 
       - name: Merge upstream changes
         if: steps.upstream_changes.outputs.updated_version == 'true'
@@ -113,6 +120,14 @@ jobs:
           git add ${{ env.SETUP_FILE }}
           git commit -m "Update supported Python versions"
 
+      - name: Update README
+        if: steps.upstream_changes.outputs.update_readme == 'true'
+        run: |
+          sed -i '1i # EbookLib-Py\n\n' "${{ env.README_FILE }}"
+          sed -i '2i This is a fork of the popular Ebooklib library that aims to keep a package updated with changes from the original codebase. Any changes to [https://github.com/aerkalov/ebooklib] are merged into this package on a weekly basis.\n' "${{ env.README_FILE }}"
+          git add ${{ env.README_FILE }}
+          git commit -m "Update README"
+
       - name: Push changes to fork
         if: steps.upstream_changes.outputs.updated_version == 'true'
         run: git push origin master

File changed: README.md
@@ -1,6 +1,10 @@
+# EbookLib-Py
+
+This is a fork of the popular Ebooklib library that aims to keep a package updated with changes from the original codebase. Any changes to [https://github.com/aerkalov/ebooklib] are merged into this package on a weekly basis.
+
 # About EbookLib
 
-EbookLib is a Python library for managing EPUB2/EPUB3 and Kindle files. It's capable of reading and writing EPUB files programmatically.
+EbookLib is a Python library for managing EPUB2/EPUB3 files. It's capable of reading and writing EPUB files programmatically.
 
 We are working on [refreshing the project](https://github.com/aerkalov/ebooklib/issues/318) so please check and comment if you have your own ideas what needs to happen with the project.
 
@@ -8,13 +12,14 @@ The API is designed to be as simple as possible, while at the same time making c
 
 EbookLib is used in [Booktype](https://github.com/sourcefabric/Booktype/) from Sourcefabric, as well as [sprits-it!](https://github.com/the-happy-hippo/sprits-it), [fanfiction2ebook](https://github.com/ltouroumov/fanfiction2ebook), [viserlalune](https://github.com/vjousse/viserlalune) and [Telemeta](https://github.com/Parisson/Telemeta).
 
-Packages of EbookLib for GNU/Linux are available in [Debian](https://packages.debian.org/python-ebooklib) and [Ubuntu](http://packages.ubuntu.com/python-ebooklib). 
+Packages of EbookLib for GNU/Linux are available in [Debian](https://packages.debian.org/python-ebooklib) and [Ubuntu](http://packages.ubuntu.com/python-ebooklib).
 
-Sphinx documentation is generated from the templates in the docs/ directory and made available at http://ebooklib.readthedocs.io
+Sphinx documentation is generated from the templates in the docs/ directory and made available at <http://ebooklib.readthedocs.io>
 
 # Usage
 
 ## Reading
+
 ```py
 import ebooklib
 from ebooklib import epub
@@ -25,8 +30,8 @@ for image in book.get_items_of_type(ebooklib.ITEM_IMAGE):
     print(image)
 ```
 
-
 ## Writing
+
 ```py
 from ebooklib import epub
 
@@ -96,10 +101,10 @@ book.spine = ["nav", c1]
 epub.write_epub("test.epub", book, {})
 ```
 
-
 # License
-EbookLib is licensed under the [AGPL license](LICENSE.txt).
 
+EbookLib is licensed under the [AGPL license](LICENSE.txt).
 
 # Authors
+
 Full list of authors is in [AUTHORS.txt](AUTHORS.txt) file.

-------------------------

Commit Hash: a7ba2d47592ed1d6b7f2c7470355ec7ab0affcb0
Commit Message: Rename project
Diff: (2 files changed)
File changed: .github/workflows/auto-update.yml
@@ -123,7 +123,7 @@ jobs:
       - name: Update README
         if: steps.upstream_changes.outputs.update_readme == 'true'
         run: |
-          sed -i '1i # EbookLib-Py\n\n' "${{ env.README_FILE }}"
+          sed -i '1i # EbookLib-autoupdate\n\n' "${{ env.README_FILE }}"
           sed -i '2i This is a fork of the popular Ebooklib library that aims to keep a package updated with changes from the original codebase. Any changes to [https://github.com/aerkalov/ebooklib] are merged into this package on a weekly basis.\n' "${{ env.README_FILE }}"
           git add ${{ env.README_FILE }}
           git commit -m "Update README"

File changed: README.md
@@ -1,4 +1,4 @@
-# EbookLib-Py
+# EbookLib-autoupdate
 
 This is a fork of the popular Ebooklib library that aims to keep a package updated with changes from the original codebase. Any changes to [https://github.com/aerkalov/ebooklib] are merged into this package on a weekly basis.
 

-------------------------

Commit Hash: 30749c3d3fc6a2b7ee78180578a7e32943e83404
Commit Message: Add requests
Diff: (2 files changed)
File changed: pyproject.toml
@@ -4,7 +4,34 @@ version = "0.18.1"
 description = "Ebook library which can handle EPUB2/EPUB3"
 readme = "README.md"
 requires-python = ">=3.6"
+license = "AGPL-3.0-only"
+authors = [
+    { name = "Aleksandar Erkalovic", email = "aerkalov@gmail.com" }
+    ]
+keywords = ["ebook", "epub"]
+classifiers = [
+    "Development Status :: 4 - Beta",
+    "Intended Audience :: Developers",
+    "Operating System :: OS Independent",
+    "Programming Language :: Python :: 3.6",
+    "Programming Language :: Python :: 3.7",
+    "Programming Language :: Python :: 3.8",
+    "Programming Language :: Python :: 3.9",
+    "Programming Language :: Python :: 3.10",
+    "Programming Language :: Python :: 3.11",
+    "Programming Language :: Python :: 3.12",
+    "Topic :: Software Development :: Libraries :: Python Modules"
+]
 dependencies = [
     "lxml>=4.9.0",
     "six>=1.0.0",
 ]
+
+[project.urls]
+"Homepage" = "https://github.com/aleksandar-erkalovic/ebooklib"
+"Documentation" = "https://ebooklib.readthedocs.io"
+
+[dependency-groups]
+workflow = [
+    "toml>=0.10.2",
+]

File changed: uv.lock

-------------------------

Commit Hash: 103c51de93691f9fa0da08f556dd4a1030640e3d
Commit Message: Create file to update setup and pyproject
Diff: (4 files changed)
File changed: .github/workflows/auto-update.yml
@@ -92,39 +92,26 @@ jobs:
           git add ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }} ${{ env.PYPROJECT_FILE }}
           git commit -m "Auto-increment version to $NEW_VERSION"
 
+          - name: Install uv
+          if: steps.upstream_changes.outputs.updated_version == 'true'
+          uses: astral-sh/setup-uv@v5
+          with:
+            enable-cache: true
+
       - name: Update supported Python versions in setup.py
         if: steps.upstream_changes.outputs.update_setup == 'true'
         run: |
-          python <<EOF
-          import re
-          supported_versions = ["3.6", "3.7", "3.8", "3.9", "3.10", "3.11", "3.12"]
-          setup_file = "${{ env.SETUP_FILE }}"
-          with open(setup_file, "r") as f:
-            original_text = f.read()
-          text = re.sub("and kindle ", "", original_text)
-          allowed_keywords = r"Keywords = ['ebook', 'epub']"
-          keyword_pattern = r"Keywords = [(?:'\w+',\s?)*'\w+']"
-          corrected_text = re.sub(keyword_pattern, allowed_keywords, text)
-          programming_line_stub = '"Programming Language :: Python :: '
-          programming_line = f'{programming_line_stub}[0-9.]+,"'
-          existing_versions = sorted(version[4:].strip() for version in re.findall(programming_line, corrected_text))
-          old_versions = rf'^\s*{programming_line}*(?:\n\s*{programming_line})*'
-          new_versions = "\n".join(
-            f'         {programming_line_stub}{version},"'
-            for version in supported_versions
-          )
-          new_version_text = re.sub(old_versions, new_versions, corrected_text, flags=re.MULTILINE)
-          with open(setup_file, "w") as f:
-            f.write(new_version_text)
-          EOF
+          uv sync --group workflow
+          chmod +x .venv/bin/activate
+          ./.venv/bin/activate
+          /.venv/bin/python .scripts/update_setup.py "${{ env.SETUP_FILE }}" "${{ env.PYPROJECT_FILE }}"
           git add ${{ env.SETUP_FILE }}
           git commit -m "Update supported Python versions"
 
       - name: Update README
         if: steps.upstream_changes.outputs.update_readme == 'true'
         run: |
-          sed -i '1i # EbookLib-autoupdate\n\n' "${{ env.README_FILE }}"
-          sed -i '2i This is a fork of the popular Ebooklib library that aims to keep a package updated with changes from the original codebase. Any changes to [https://github.com/aerkalov/ebooklib] are merged into this package on a weekly basis.\n' "${{ env.README_FILE }}"
+          python .scripts/update_readme.py "${{ env.README_FILE }}"
           git add ${{ env.README_FILE }}
           git commit -m "Update README"
 
@@ -132,12 +119,6 @@ jobs:
         if: steps.upstream_changes.outputs.updated_version == 'true'
         run: git push origin master
 
-      - name: Install uv
-        if: steps.upstream_changes.outputs.updated_version == 'true'
-        uses: astral-sh/setup-uv@v5
-        with:
-          enable-cache: true
-
       - name: Build and publish
         if: steps.upstream_changes.outputs.updated_version == 'true'
         run: |

File added: .scripts/update_readme.py
@@ -0,0 +1,35 @@
+import re
+import sys
+
+
+def update_readme(readme_file: str) -> None:
+    with open(readme_file, "r") as f:
+        content: str = f.read()
+
+    sections: list[str] = re.split(r"(```.*?```)", content, flags=re.DOTALL)
+    updated_sections: list[str] = []
+
+    for section in sections:
+        if not section.startswith("```"):
+            section = re.sub(
+                r"^(#+)(\s)", r"#\1\2", section, flags=re.MULTILINE
+            )
+            section = section.replace("and kindle ", "")
+        updated_sections.append(section)
+
+    preamble = (
+        "# EbookLib-autoupdate\n\n"
+        "This is a fork of the popular Ebooklib library that aims to keep a "
+        "package updated with changes from the original codebase. Any changes"
+        " to [https://github.com/aerkalov/ebooklib] are merged into this "
+        "package on a weekly basis.\n\n"
+    )
+
+    text = preamble + "".join(updated_sections)
+
+    with open(readme_file, "w") as f:
+        f.write(text)
+
+
+if __name__ == "__main__":
+    update_readme(sys.argv[1])

File added: .scripts/update_setup.py
@@ -0,0 +1,144 @@
+import re
+import sys
+
+import requests
+import toml
+
+
+def create_author_line(sections: dict) -> str:
+    name = sections["author"]
+    email = sections["email"]
+
+    return "{ " + f"name = {name}, email = {email} " + "}"
+
+
+def convert_long_description(long_description: str) -> str:
+    return long_description.lstrip("read(").rstrip(")").strip("'\"")
+
+
+def fetch_license_data(url: str) -> dict:
+    """Fetch the license JSON from the given URL."""
+    response = requests.get(url, timeout=10)
+    response.raise_for_status()  # Raise an error for HTTP issues
+    return response.json()
+
+
+def find_license_id(license_name: str, license_data: dict) -> str:
+    licenses = license_data.get("licenses", [])
+    normalized_name = license_name.lower().strip()
+
+    matches = [
+        license["licenseId"]
+        for license in licenses
+        if normalized_name in license["name"].lower()
+    ]
+    return matches[0] if matches else ""
+
+
+def convert_license(license: str) -> str:
+    spdx_url = "https://raw.githubusercontent.com/spdx/license-list-data/refs/heads/main/json/licenses.json"
+    license_data = fetch_license_data(spdx_url)
+    if spdx_id := find_license_id(license, license_data):
+        return spdx_id
+    else:
+        raise ValueError(f"License ID not found for '{license}'")
+
+
+def parse_setup(setup_file: str) -> dict[str, str | list[str]]:
+    setup_sections = {
+        "author": str,
+        "author_email": str,
+        "url": str,
+        "license": str,
+        "description": str,
+        "long_description": str,
+        "keywords": list,
+        "classifiers": list,
+        "install_requires": list,
+    }
+
+    sections: dict[str, str | list[str]] = {
+        key: [] if isinstance(val, list) else ""
+        for key, val in setup_sections.items()
+    }
+
+    with open(setup_file, "r") as file:
+        lines = iter(line.strip() for line in file)
+
+    key = ""
+    for line in lines:
+        if "=" in line:
+            key, value = (part.strip() for part in line.split("=", 1))
+            if key in setup_sections:
+                if value.startswith("["):
+                    sections[key] = []
+                    value = value.lstrip("[")
+                else:
+                    sections[key] = value.strip("\"'")
+
+        elif isinstance(sections[key], list):
+            if line == "]":
+                continue
+            sections[key].append(line.strip("\"'"))
+
+    sections["author"] = create_author_line(sections)
+    sections.pop("author_email")
+    sections["readme"] = convert_long_description(sections["long_description"])
+    sections.pop("long_description")
+    sections["license"] = convert_license["convert_license"]
+
+    return sections
+
+
+def update_pyproject(toml_file: str, sections: dict[str, str | list[str]]):
+    """Updates pyproject.toml with new values."""
+    with open(toml_file, "r") as f:
+        data = toml.load(f)
+
+    for key, value in sections.items():
+        if key == "url":
+            data["project.urls"]["Homepage"] = value
+        elif key == "install_requires":
+            for dependency in data["project"]["dependencies"]:
+                if dependency not in value:
+                    data["project"]["dependencies"].remove(dependency)
+        else:
+            data["project"][key] = value
+
+    with open(toml_file, "w") as f:
+        toml.dump(data, f)
+
+
+def update_setup(setup_file) -> str:
+    supported_versions = ["3.6", "3.7", "3.8", "3.9", "3.10", "3.11", "3.12"]
+
+    with open(setup_file, "r") as f:
+        text = f.read()
+
+    text = text.replace("and kindle ", "")
+
+    allowed_keywords = r"Keywords = ['ebook', 'epub']"
+    keyword_pattern = r"Keywords = [(?:'\w+',\s?)*'\w+']"
+
+    corrected_text = re.sub(keyword_pattern, allowed_keywords, text)
+
+    programming_line_stub = '"Programming Language :: Python :: '
+    programming_line = f'{programming_line_stub}[0-9.]+,"'
+
+    old_versions = rf"^\s*{programming_line}*(?:\n\s*{programming_line})*"
+    new_versions = "\n".join(
+        f'         {programming_line_stub}{version},"'
+        for version in supported_versions
+    )
+    new_version_text = re.sub(
+        old_versions, new_versions, corrected_text, flags=re.MULTILINE
+    )
+
+    with open(setup_file, "w") as f:
+        f.write(new_version_text)
+
+
+if __name__ == "__main__":
+    update_setup(sys.argv[1])
+    sections = parse_setup(sys.argv[1])
+    update_pyproject(sys.argv[2], sections)

File changed: setup.py
@@ -12,18 +12,18 @@ def read(path):
 
 
 setup(
-    name = 'EbookLib',
-    version = '0.18.1',
-    author = 'Aleksandar Erkalovic',
-    author_email = 'aerkalov@gmail.com',
-    packages = ['ebooklib', 'ebooklib.plugins'],
-    url = 'https://github.com/aerkalov/ebooklib',
-    license = 'GNU Affero General Public License',
-    description = 'Ebook library which can handle EPUB2/EPUB3 format',
-    long_description = read('README.md'),
-    long_description_content_type = 'text/markdown',
-    keywords = ['ebook', 'epub'],
-    classifiers = [
+    name="EbookLib",
+    version="0.18.1",
+    author="Aleksandar Erkalovic",
+    author_email="aerkalov@gmail.com",
+    packages=["ebooklib", "ebooklib.plugins"],
+    url="https://github.com/aerkalov/ebooklib",
+    license="GNU Affero General Public License",
+    description="Ebook library which can handle EPUB2/EPUB3 format",
+    long_description=read("README.md"),
+    long_description_content_type="text/markdown",
+    keywords=["ebook", "epub"],
+    classifiers=[
         "Development Status :: 4 - Beta",
         "Intended Audience :: Developers",
         "Operating System :: OS Independent",
@@ -34,10 +34,7 @@ setup(
         "Programming Language :: Python :: 3.10",
         "Programming Language :: Python :: 3.11",
         "Programming Language :: Python :: 3.12",
-        "Topic :: Software Development :: Libraries :: Python Modules"
+        "Topic :: Software Development :: Libraries :: Python Modules",
     ],
-    install_requires = [
-       "lxml", "six"
-    ]
+    install_requires=["lxml", "six"],
 )
-

-------------------------

Commit Hash: 32c43a61576b04b629e674c9423f86b46b63446e
Commit Message: Fix dependency removal
Diff: (1 files changed)
File changed: .scripts/update_setup.py
@@ -1,3 +1,10 @@
+# /// script
+# dependencies = [
+#     "requests",
+#     "toml",
+# ]
+# ///
+
 import re
 import sys
 
@@ -7,7 +14,7 @@ import toml
 
 def create_author_line(sections: dict) -> str:
     name = sections["author"]
-    email = sections["email"]
+    email = sections["author_email"]
 
     return "{ " + f"name = {name}, email = {email} " + "}"
 
@@ -63,7 +70,9 @@ def parse_setup(setup_file: str) -> dict[str, str | list[str]]:
     }
 
     with open(setup_file, "r") as file:
-        lines = iter(line.strip() for line in file)
+        lines = [line.strip() for line in file]
+
+    lines = iter(lines)
 
     key = ""
     for line in lines:
@@ -76,7 +85,7 @@ def parse_setup(setup_file: str) -> dict[str, str | list[str]]:
                 else:
                     sections[key] = value.strip("\"'")
 
-        elif isinstance(sections[key], list):
+        elif isinstance(sections.get(key), list):
             if line == "]":
                 continue
             sections[key].append(line.strip("\"'"))
@@ -85,7 +94,7 @@ def parse_setup(setup_file: str) -> dict[str, str | list[str]]:
     sections.pop("author_email")
     sections["readme"] = convert_long_description(sections["long_description"])
     sections.pop("long_description")
-    sections["license"] = convert_license["convert_license"]
+    sections["license"] = convert_license(sections["license"])
 
     return sections
 
@@ -95,13 +104,28 @@ def update_pyproject(toml_file: str, sections: dict[str, str | list[str]]):
     with open(toml_file, "r") as f:
         data = toml.load(f)
 
+    dependencies: dict[str, str] = {
+        re.split(r"[<>=!~]", dependency)[0].strip(): dependency
+        for dependency in data["project"]["dependencies"]
+    }
+
+    requires_python = min(
+        classifier.strip("Programming Language :: Python :: ")
+        for classifier in sections["classifiers"]
+        if "Python" in classifier
+    )
+
+    data["project"]["requires-python"] = f">={requires_python}"
+
     for key, value in sections.items():
-        if key == "url":
-            data["project.urls"]["Homepage"] = value
-        elif key == "install_requires":
-            for dependency in data["project"]["dependencies"]:
+        if key == "install_requires":
+            for dependency in dependencies:
                 if dependency not in value:
-                    data["project"]["dependencies"].remove(dependency)
+                    data["project"]["dependencies"].remove(
+                        dependencies[dependency]
+                    )
+        elif key == "url":
+            data["project"]["urls"]["Homepage"] = value
         else:
             data["project"][key] = value
 

-------------------------

Commit Hash: 932bc5821f16743d215465fcbf63714728477951
Commit Message: Fix license fetch with generator
Diff: (1 files changed)
File changed: .scripts/update_setup.py
@@ -7,6 +7,7 @@
 
 import re
 import sys
+from collections.abc import Generator
 
 import requests
 import toml
@@ -30,22 +31,24 @@ def fetch_license_data(url: str) -> dict:
     return response.json()
 
 
-def find_license_id(license_name: str, license_data: dict) -> str:
+def find_license_id(
+    license_name: str, license_data: dict
+) -> Generator[str, None, None]:
+    """Find the license ID for the given license name."""
     licenses = license_data.get("licenses", [])
     normalized_name = license_name.lower().strip()
 
-    matches = [
+    yield from (
         license["licenseId"]
         for license in licenses
-        if normalized_name in license["name"].lower()
-    ]
-    return matches[0] if matches else ""
+        if license["name"].lower().startswith(normalized_name)
+    )
 
 
 def convert_license(license: str) -> str:
     spdx_url = "https://raw.githubusercontent.com/spdx/license-list-data/refs/heads/main/json/licenses.json"
     license_data = fetch_license_data(spdx_url)
-    if spdx_id := find_license_id(license, license_data):
+    if spdx_id := next(find_license_id(license, license_data)):
         return spdx_id
     else:
         raise ValueError(f"License ID not found for '{license}'")

-------------------------

Commit Hash: 74d3855761304ad34e1f53ee9758f469c05c96b5
Commit Message: Add parsing authors file
Diff: (1 files changed)
File changed: .scripts/update_setup.py
@@ -54,6 +54,25 @@ def convert_license(license: str) -> str:
         raise ValueError(f"License ID not found for '{license}'")
 
 
+def read_lines(file_path: str) -> Generator[str, None, None]:
+    """Returns a list of lines stripped of whitespace"""
+    with open(file_path, "r", encoding="utf-8") as file:
+        yield from (line for line in map(str.strip, file) if line)
+
+
+def parse_authors(authors_file: str) -> dict[str, str]:
+    """Parse the authors file and return a dictionary of names and emails."""
+    authors = {}
+
+    for line in read_lines(authors_file):
+        if line.startswith("Listed"):
+            continue
+        name, email = line.split(" <") if "<" in line else (line, "")
+        authors[name] = email.strip(">")
+
+    return authors
+
+
 def parse_setup(setup_file: str) -> dict[str, str | list[str]]:
     setup_sections = {
         "author": str,

-------------------------

Commit Hash: e9037f0a04309316886f803f49fbda19a24174a2
Commit Message: parse setup.py with ast
Diff: (1 files changed)
File changed: .scripts/update_setup.py
@@ -5,6 +5,7 @@
 # ]
 # ///
 
+import ast
 import re
 import sys
 from collections.abc import Generator
@@ -155,33 +156,123 @@ def update_pyproject(toml_file: str, sections: dict[str, str | list[str]]):
         toml.dump(data, f)
 
 
-def update_setup(setup_file) -> str:
-    supported_versions = ["3.6", "3.7", "3.8", "3.9", "3.10", "3.11", "3.12"]
+def update_setup_config(
+    config: dict[str, str | list[str]], supported_versions: list[str]
+) -> dict[str, str | list[str]]:
+    """
+    Update the setup configuration dictionary with new values.
+    """
+    description = config["description"]
+    config["description"] = description.replace("and kindle ", "").replace(
+        "and Kindle ", ""
+    )
 
-    with open(setup_file, "r") as f:
-        text = f.read()
+    config["keywords"] = ["ebook", "epub"]
 
-    text = text.replace("and kindle ", "")
+    classifiers = config["classifiers"]
+    new_classifiers = []
+    python_section_added = False
 
-    allowed_keywords = r"Keywords = ['ebook', 'epub']"
-    keyword_pattern = r"Keywords = [(?:'\w+',\s?)*'\w+']"
+    for classifier in classifiers:
+        if "Programming Language :: Python :: " not in classifier:
+            new_classifiers.append(classifier)
+            continue
+        if python_section_added:
+            continue
+        python_section_added = True
+        new_classifiers.extend(
+            f"Programming Language :: Python :: {version}"
+            for version in supported_versions
+        )
+
+    config["classifiers"] = new_classifiers
+    return config
+
+
+def get_value(node: ast.AST) -> str | list[str]:
+    """Helper function to convert AST nodes to Python values"""
+    nodes = {
+        ast.Constant: lambda n: n.value,
+        ast.List: lambda n: [get_value(elt) for elt in n.elts],
+        ast.Call: lambda n: get_value(n.args[0]),
+    }
+    return nodes[type(node)](node)
 
-    corrected_text = re.sub(keyword_pattern, allowed_keywords, text)
 
-    programming_line_stub = '"Programming Language :: Python :: '
-    programming_line = f'{programming_line_stub}[0-9.]+,"'
+def make_value(value: str | list[str]) -> ast.AST:
+    nodes = {
+        str: ast.Constant(value),
+        list: ast.List(
+            elts=[ast.Constant(value=x) for x in value], ctx=ast.Load()
+        ),
+    }
+    return nodes[type(value)]
 
-    old_versions = rf"^\s*{programming_line}*(?:\n\s*{programming_line})*"
-    new_versions = "\n".join(
-        f'         {programming_line_stub}{version},"'
-        for version in supported_versions
-    )
-    new_version_text = re.sub(
-        old_versions, new_versions, corrected_text, flags=re.MULTILINE
+
+def make_call_value(id: str, value: str) -> ast.Call:
+    return ast.Call(
+        func=ast.Name(id=id, ctx=ast.Load()), args=[make_value(value)]
     )
 
+
+def extract_setup_keywords(ast_tree: ast.AST) -> dict[str, str | list[str]]:
+    """
+    Extract keyword arguments and their values from the setup() call in an AST
+    """
+    for node in ast.walk(ast_tree):
+        if (
+            hasattr(node, "value")
+            and hasattr(node.value, "func")
+            and hasattr(node.value.func, "id")
+            and node.value.func.id == "setup"
+        ):
+            return {
+                keyword.arg: get_value(keyword.value)
+                for keyword in node.value.keywords
+            }
+    raise ValueError("setup() call not found")
+
+
+def build_setup_ast(
+    tree: ast.AST, config: dict[str, str | list[str]]
+) -> ast.AST:
+    """
+    Build a new AST for setup.py from config dictionary.
+    """
+    keywords = []
+    for key, value in config.items():
+        ast.keyword(
+            arg=key, value=make_call_value("read", value)
+        ) if key == "long_description" else ast.keyword(
+            arg=key, value=make_value(value)
+        )
+
+    for node in ast.walk(tree):
+        if (
+            hasattr(node, "value")
+            and hasattr(node.value, "func")
+            and hasattr(node.value.func, "id")
+            and node.value.func.id == "setup"
+        ):
+            node.value.keywords = keywords
+
+    return tree
+
+
+def update_setup(setup_file: str) -> dict[str, str | list[str]]:
+    with open(setup_file, "r") as f:
+        tree = ast.parse(f.read())
+
+    supported_versions = ["3.6", "3.7", "3.8", "3.9", "3.10", "3.11", "3.12"]
+
+    keywords = extract_setup_keywords(tree)
+    updated_keywords = update_setup_config(keywords, supported_versions)
+    transformed_ast = build_setup_ast(tree, updated_keywords)
+
     with open(setup_file, "w") as f:
-        f.write(new_version_text)
+        f.write(ast.unparse(transformed_ast))
+
+    return updated_keywords
 
 
 if __name__ == "__main__":

-------------------------

Commit Hash: 42a4b152f88c17d9f6600957617f06007ab8a61f
Commit Message: Add tomlkit dependency for workflow group
Diff: (2 files changed)
File changed: pyproject.toml
@@ -34,4 +34,5 @@ dependencies = [
 [dependency-groups]
 workflow = [
     "toml>=0.10.2",
+    "tomlkit>=0.11.6",
 ]

File changed: uv.lock

-------------------------

Commit Hash: 3d5fb5ddaff41459a14c47adeb78a493ae4f25f6
Commit Message: Use tomlkit to update toml file
Diff: (1 files changed)
File changed: .scripts/update_setup.py
@@ -1,7 +1,7 @@
 # /// script
 # dependencies = [
 #     "requests",
-#     "toml",
+#     "tomlkit",
 # ]
 # ///
 
@@ -11,7 +11,8 @@ import sys
 from collections.abc import Generator
 
 import requests
-import toml
+import tomlkit
+from tomlkit.items import Array, Table
 
 
 def create_author_line(sections: dict) -> str:
@@ -122,38 +123,148 @@ def parse_setup(setup_file: str) -> dict[str, str | list[str]]:
     return sections
 
 
-def update_pyproject(toml_file: str, sections: dict[str, str | list[str]]):
-    """Updates pyproject.toml with new values."""
-    with open(toml_file, "r") as f:
-        data = toml.load(f)
+def create_inline_array(input_dict: dict[str, str]) -> Array:
+    """Creates a tomlkit array on inline tables for authors/maintainers"""
+    array = tomlkit.array()
+    for name, email in input_dict.items():
+        inline_table = tomlkit.inline_table()
+        inline_table.update(
+            {"name": name, "email": email} if email else {"name": name}
+        )
+        array.append(inline_table)
+
+    return array
+
 
+def update_classifiers(classifiers: list[str]) -> Array:
+    """Creates a tomlkit array of project classifiers"""
+    array = tomlkit.array()
+    array.extend(classifiers)
+    return array
+
+
+def update_dependencies(
+    requirements: list[str], proj_dependencies: list[str]
+) -> Array:
+    """
+    Creates a tomlkit array of project dependencies from existing dependencies
+    and requirements
+    """
+    array = tomlkit.array()
     dependencies: dict[str, str] = {
         re.split(r"[<>=!~]", dependency)[0].strip(): dependency
-        for dependency in data["project"]["dependencies"]
+        for dependency in proj_dependencies
     }
 
+    array.extend(dependencies[package] for package in requirements)
+    return array
+
+
+def update_maintainers(sections: dict[str, str | list[str]]) -> Array:
+    """Creates an array of project maintainers"""
+    maintainers = {
+        sections["maintainer"]: sections["maintainer_email"],
+        "Ashlynn Antrobus": "ashlynn@prosepal.io",
+    }
+    return create_inline_array(maintainers)
+
+
+def update_py_version(classifiers: list[str]) -> str:
+    """Build the `requires_python` string"""
     requires_python = min(
-        classifier.strip("Programming Language :: Python :: ")
-        for classifier in sections["classifiers"]
-        if "Python" in classifier
+        (
+            classifier.strip("Programming Language :: Python :: ")
+            for classifier in classifiers
+            if "Programming Language" in classifier
+        ),
+        key=lambda version: int(version.split(".")[1]),
     )
 
-    data["project"]["requires-python"] = f">={requires_python}"
-
-    for key, value in sections.items():
-        if key == "install_requires":
-            for dependency in dependencies:
-                if dependency not in value:
-                    data["project"]["dependencies"].remove(
-                        dependencies[dependency]
-                    )
-        elif key == "url":
-            data["project"]["urls"]["Homepage"] = value
-        else:
-            data["project"][key] = value
-
-    with open(toml_file, "w") as f:
-        toml.dump(data, f)
+    return f">={requires_python}"
+
+
+def update_urls(proj_urls: Table, home_url: str) -> Table:
+    """Create a urls table from new homepage url and other existing urls"""
+    urls = tomlkit.table()
+    urls.add("Homepage", home_url)
+    for page, url in proj_urls.value.body:
+        if page != "Homepage":
+            urls.add(page, url)
+    return urls
+
+
+def update_table_item(
+    item: str, project: Table, sections: dict, authors: dict
+) -> Table:
+    """Returns the updated value for a project table item."""
+    handlers = {
+        "authors": lambda: create_inline_array(authors),
+        "classifiers": lambda: update_classifiers(sections["classifiers"]),
+        "dependencies": lambda: update_dependencies(
+            sections["install_requires"], project["dependencies"]
+        ),
+        "maintainers": lambda: update_maintainers(sections),
+        "requires-python": lambda: update_py_version(sections["classifiers"]),
+        "urls": lambda: update_urls(project["urls"], sections["url"]),
+    }
+    value = handlers.get(item, lambda: sections.get(item))()
+    if item in {"classifiers", "dependencies", "authors", "maintainers"}:
+        value.multiline(True)
+    return value
+
+
+def sort_project_table(
+    toml: tomlkit.TOMLDocument,
+    sections: dict[str, str | list],
+    authors: dict[str, str],
+) -> tomlkit.TOMLDocument:
+    order = [
+        "name",
+        "version",
+        "description",
+        "readme",
+        "requires-python",
+        "license",
+        "keywords",
+        "classifiers",
+        "maintainers",
+        "authors",
+        "nl",  # A blank line
+        "dependencies",
+        "urls",
+    ]
+
+    table = tomlkit.table()
+
+    for item in order:
+        if item == "nl":
+            table.add(tomlkit.nl())
+            continue
+        value = (
+            update_table_item(item, toml["project"], sections, authors)
+            or toml["project"][item]
+        )
+        table.raw_append(item, value)
+
+    toml["project"] = table
+
+    return toml
+
+
+def update_pyproject(
+    toml_file: str,
+    sections: dict[str, str | list[str]],
+    authors: dict[str, str],
+) -> None:
+    """Updates pyproject.toml with new values."""
+    with open(toml_file, "r", encoding="utf-8") as f:
+        doc = tomlkit.load(f)
+
+    updated_doc = sort_project_table(doc, sections, authors)
+    toml_text = re.sub("\n\n\n", "\n\n", tomlkit.dumps(updated_doc))
+
+    with open(toml_file, "w", encoding="utf-8") as f:
+        f.write(toml_text)
 
 
 def update_setup_config(

-------------------------

Commit Hash: 80fe0dd9e7b178a14189dc76247dcf592bc710a1
Commit Message: parse setup file from ast keywords
Diff: (1 files changed)
File changed: .scripts/update_setup.py
@@ -15,17 +15,6 @@ import tomlkit
 from tomlkit.items import Array, Table
 
 
-def create_author_line(sections: dict) -> str:
-    name = sections["author"]
-    email = sections["author_email"]
-
-    return "{ " + f"name = {name}, email = {email} " + "}"
-
-
-def convert_long_description(long_description: str) -> str:
-    return long_description.lstrip("read(").rstrip(")").strip("'\"")
-
-
 def fetch_license_data(url: str) -> dict:
     """Fetch the license JSON from the given URL."""
     response = requests.get(url, timeout=10)
@@ -75,50 +64,40 @@ def parse_authors(authors_file: str) -> dict[str, str]:
     return authors
 
 
-def parse_setup(setup_file: str) -> dict[str, str | list[str]]:
-    setup_sections = {
-        "author": str,
-        "author_email": str,
-        "url": str,
-        "license": str,
-        "description": str,
-        "long_description": str,
-        "keywords": list,
-        "classifiers": list,
-        "install_requires": list,
-    }
+def strip_string(string: str, chars: str = "\"',[]") -> str:
+    """Strip quotes, brackets, and commas from a string."""
+    return string.strip(chars)
 
-    sections: dict[str, str | list[str]] = {
-        key: [] if isinstance(val, list) else ""
-        for key, val in setup_sections.items()
-    }
 
-    with open(setup_file, "r") as file:
-        lines = [line.strip() for line in file]
-
-    lines = iter(lines)
-
-    key = ""
-    for line in lines:
-        if "=" in line:
-            key, value = (part.strip() for part in line.split("=", 1))
-            if key in setup_sections:
-                if value.startswith("["):
-                    sections[key] = []
-                    value = value.lstrip("[")
-                else:
-                    sections[key] = value.strip("\"'")
-
-        elif isinstance(sections.get(key), list):
-            if line == "]":
-                continue
-            sections[key].append(line.strip("\"'"))
-
-    sections["author"] = create_author_line(sections)
-    sections.pop("author_email")
-    sections["readme"] = convert_long_description(sections["long_description"])
-    sections.pop("long_description")
-    sections["license"] = convert_license(sections["license"])
+def convert_long_description(long_description: str) -> str:
+    return long_description.lstrip("read(").rstrip(")").strip("'\"")
+
+
+def parse_setup(
+    setup_keywords: dict[str, str | list[str]],
+) -> dict[str, str | list[str]]:
+    """Parse the setup.py file and return a dictionary of sections."""
+    setup_sections: list[str] = [
+        "version",
+        "author",
+        "author_email",
+        "url",
+        "license",
+        "description",
+        "long_description",
+        "keywords",
+        "classifiers",
+        "install_requires",
+    ]
+
+    sections = {keyword: setup_keywords[keyword] for keyword in setup_sections}
+
+    sections |= {
+        "readme": sections.pop("long_description"),
+        "license": convert_license(sections["license"]),
+        "maintainer": sections.pop("author"),
+        "maintainer_email": sections.pop("author_email"),
+    }
 
     return sections
 
@@ -163,8 +142,8 @@ def update_dependencies(
 def update_maintainers(sections: dict[str, str | list[str]]) -> Array:
     """Creates an array of project maintainers"""
     maintainers = {
-        sections["maintainer"]: sections["maintainer_email"],
         "Ashlynn Antrobus": "ashlynn@prosepal.io",
+        sections["maintainer"]: sections["maintainer_email"],
     }
     return create_inline_array(maintainers)
 
@@ -387,6 +366,7 @@ def update_setup(setup_file: str) -> dict[str, str | list[str]]:
 
 
 if __name__ == "__main__":
-    update_setup(sys.argv[1])
-    sections = parse_setup(sys.argv[1])
-    update_pyproject(sys.argv[2], sections)
+    keywords = update_setup(sys.argv[1])
+    authors = parse_authors(sys.argv[2])
+    sections = parse_setup(keywords)
+    update_pyproject(sys.argv[3], sections, authors)

-------------------------

Commit Hash: 129635a41252ba0a7c08917bb4b403b337d01d6c
Commit Message: Fix: Keywords were not added to keywords list
Diff: (1 files changed)
File changed: .scripts/update_setup.py
@@ -330,12 +330,14 @@ def build_setup_ast(
     Build a new AST for setup.py from config dictionary.
     """
     keywords = []
-    for key, value in config.items():
-        ast.keyword(
-            arg=key, value=make_call_value("read", value)
-        ) if key == "long_description" else ast.keyword(
-            arg=key, value=make_value(value)
+    keywords.extend(
+        (
+            ast.keyword(arg=key, value=make_call_value("read", value))
+            if key == "long_description"
+            else ast.keyword(arg=key, value=make_value(value))
         )
+        for key, value in config.items()
+    )
 
     for node in ast.walk(tree):
         if (

-------------------------

Commit Hash: 33c68372763865822ff036269834b06d7c33e08f
Commit Message: Add author file & ruff format
Diff: (1 files changed)
File changed: .github/workflows/auto-update.yml
@@ -12,6 +12,7 @@ permissions:
 env:
   VERSION_FILE: VERSION.txt
   SETUP_FILE: setup.py
+  AUTHORS_FILE: AUTHORS.txt
   PYPROJECT_FILE: pyproject.toml
   README_FILE: README.md
 
@@ -104,15 +105,16 @@ jobs:
           uv sync --group workflow
           chmod +x .venv/bin/activate
           ./.venv/bin/activate
-          /.venv/bin/python .scripts/update_setup.py "${{ env.SETUP_FILE }}" "${{ env.PYPROJECT_FILE }}"
-          git add ${{ env.SETUP_FILE }}
+          /.venv/bin/python .scripts/update_setup.py "${{ env.SETUP_FILE }}" "${{ env.AUTHORS_FILE }}" "${{ env.PYPROJECT_FILE }}"
+          uvx ruff format
+          git add "${{ env.SETUP_FILE }}"" "${{ env.PYPROJECT_FILE }}"
           git commit -m "Update supported Python versions"
 
       - name: Update README
         if: steps.upstream_changes.outputs.update_readme == 'true'
         run: |
           python .scripts/update_readme.py "${{ env.README_FILE }}"
-          git add ${{ env.README_FILE }}
+          git add "${{ env.README_FILE }}"
           git commit -m "Update README"
 
       - name: Push changes to fork

-------------------------

Commit Hash: ae9780fe654cb3a0ed39a54b9ab866fa3e2b8688
Commit Message: Add helper function for setup call
Diff: (2 files changed)
File changed: .scripts/update_setup.py
@@ -305,17 +305,24 @@ def make_call_value(id: str, value: str) -> ast.Call:
     )
 
 
+def is_setup_call(node: ast.AST) -> bool:
+    """
+    Check if the node is a call to the `setup` function.
+    """
+    return (
+        hasattr(node, "value")
+        and hasattr(node.value, "func")
+        and hasattr(node.value.func, "id")
+        and node.value.func.id == "setup"
+    )
+
+
 def extract_setup_keywords(ast_tree: ast.AST) -> dict[str, str | list[str]]:
     """
     Extract keyword arguments and their values from the setup() call in an AST
     """
     for node in ast.walk(ast_tree):
-        if (
-            hasattr(node, "value")
-            and hasattr(node.value, "func")
-            and hasattr(node.value.func, "id")
-            and node.value.func.id == "setup"
-        ):
+        if is_setup_call(node):
             return {
                 keyword.arg: get_value(keyword.value)
                 for keyword in node.value.keywords
@@ -329,23 +336,15 @@ def build_setup_ast(
     """
     Build a new AST for setup.py from config dictionary.
     """
-    keywords = []
-    keywords.extend(
-        (
-            ast.keyword(arg=key, value=make_call_value("read", value))
-            if key == "long_description"
-            else ast.keyword(arg=key, value=make_value(value))
-        )
+    keywords = [
+        ast.keyword(arg=key, value=make_call_value("read", value))
+        if key == "long_description"
+        else ast.keyword(arg=key, value=make_value(value))
         for key, value in config.items()
-    )
+    ]
 
     for node in ast.walk(tree):
-        if (
-            hasattr(node, "value")
-            and hasattr(node.value, "func")
-            and hasattr(node.value.func, "id")
-            and node.value.func.id == "setup"
-        ):
+        if is_setup_call(node):
             node.value.keywords = keywords
 
     return tree

File changed: pyproject.toml
@@ -33,6 +33,5 @@ dependencies = [
 
 [dependency-groups]
 workflow = [
-    "toml>=0.10.2",
     "tomlkit>=0.11.6",
 ]

-------------------------

Commit Hash: 77643c4599aac13fb698d707a90a8b2324fbeb97
Commit Message: update dependencies
Diff: (2 files changed)
File changed: pyproject.toml
@@ -1,13 +1,10 @@
 [project]
 name = "ebooklib-autoupdate"
 version = "0.18.1"
-description = "Ebook library which can handle EPUB2/EPUB3"
+description = "Ebook library which can handle EPUB2/EPUB3 format"
 readme = "README.md"
 requires-python = ">=3.6"
-license = "AGPL-3.0-only"
-authors = [
-    { name = "Aleksandar Erkalovic", email = "aerkalov@gmail.com" }
-    ]
+license = "AGPL-3.0"
 keywords = ["ebook", "epub"]
 classifiers = [
     "Development Status :: 4 - Beta",
@@ -20,15 +17,54 @@ classifiers = [
     "Programming Language :: Python :: 3.10",
     "Programming Language :: Python :: 3.11",
     "Programming Language :: Python :: 3.12",
-    "Topic :: Software Development :: Libraries :: Python Modules"
+    "Topic :: Software Development :: Libraries :: Python Modules",
+]
+maintainers = [
+    {name = "Ashlynn Antrobus", email = "ashlynn@prosepal.io"},
+    {name = "Aleksandar Erkalovic", email = "aerkalov@gmail.com"},
 ]
+authors = [
+    {name = "Aleksandar Erkalovic", email = "aerkalov@gmail.com"},
+    {name = "Borko Jandras", email = "bjandras@gmail.com"},
+    {name = "the-happy-hippo", email = "th3hh0@gmail.com"},
+    {name = "Daniel James", email = "daniel@64studio.com"},
+    {name = "Mikhail Gusarov", email = "dottedmag@dottedmag.net"},
+    {name = "Raymond Yee", email = "raymond.yee@gmail.com"},
+    {name = "Chris Grice", email = "chris@chrisgrice.com"},
+    {name = "Fernando Wime", email = "fernando.d@wime.com.mx"},
+    {name = "Andy Roberts", email = "andy.roberts.uk@gmail.com"},
+    {name = "Tom McLean", email = "tom.a.mclean@gmail.com"},
+    {name = "Travis L", email = "leleu@industrialinterface.com"},
+    {name = "Helmy Giacoman", email = "helmygb@gmail.com"},
+    {name = "clach04", email = "Chris.Clark@actian.com"},
+    {name = "Edward Betts", email = "edward@4angle.com"},
+    {name = "Kennyl", email = "Kennyl@users.noreply.github.com"},
+    {name = "Oleg Pshenichniy", email = "olegpshenichniy@gmail.com"},
+    {name = "Olivier Le Thanh Duong", email = "olivier@lethanh.be"},
+    {name = "Michael Storm", email = "mstorm7@gmail.com"},
+    {name = "Sergey Markelov"},
+    {name = "Laurent Laporte", email = "tantale.solutions@gmail.com"},
+    {name = "Deborah Kaplan", email = "deborahgu@users.noreply.github.com"},
+    {name = "Willem van der Walt", email = "wvdwalt@csir.co.za"},
+    {name = "Peter", email = "82152909+repeterat@users.noreply.github.com"},
+    {name = "u8slvn", email = "u8slvn@gmail.com"},
+    {name = "tugot17", email = "piotr635@gmail.com"},
+    {name = "张悦", email = "zhangyue@xtzx.com"},
+    {name = "Morphus", email = "mr.morphus@gmail.com"},
+    {name = "Kian-Meng, Ang", email = "kianmeng@cpan.org"},
+    {name = "Jared Wong", email = "jaredlwong@gmail.com"},
+    {name = "Michael Timblin", email = "mjtimblin@gmail.com"},
+    {name = "Hsiu-Ming Chang", email = "cges30901@gmail.com"},
+    {name = "Bono Lv", email = "lvscar@gmail.com"},
+    {name = "Tom Ritchford", email = "tom@swirly.com"},
+]
+
 dependencies = [
     "lxml>=4.9.0",
-    "six>=1.0.0",
 ]
 
 [project.urls]
-"Homepage" = "https://github.com/aleksandar-erkalovic/ebooklib"
+Homepage = "https://github.com/aerkalov/ebooklib"
 "Documentation" = "https://ebooklib.readthedocs.io"
 
 [dependency-groups]

File changed: uv.lock

-------------------------

Commit Hash: 73124dc1fd3a67bd798e5805aeb2f01cf725d5cf
Commit Message: install Python 3.12
Diff: (1 files changed)
File changed: .github/workflows/auto-update.yml
@@ -93,19 +93,22 @@ jobs:
           git add ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }} ${{ env.PYPROJECT_FILE }}
           git commit -m "Auto-increment version to $NEW_VERSION"
 
-          - name: Install uv
-          if: steps.upstream_changes.outputs.updated_version == 'true'
-          uses: astral-sh/setup-uv@v5
-          with:
-            enable-cache: true
+      - name: Install uv
+        if: steps.upstream_changes.outputs.updated_version == 'true'
+        uses: astral-sh/setup-uv@v5
+        with:
+          enable-cache: true
+
+      - name: "Set up Python"
+        if: steps.upstream_changes.outputs.updated_version == 'true'
+        uses: actions/setup-python@v5
+        with:
+          python-version: "3.12"
 
       - name: Update supported Python versions in setup.py
         if: steps.upstream_changes.outputs.update_setup == 'true'
         run: |
-          uv sync --group workflow
-          chmod +x .venv/bin/activate
-          ./.venv/bin/activate
-          /.venv/bin/python .scripts/update_setup.py "${{ env.SETUP_FILE }}" "${{ env.AUTHORS_FILE }}" "${{ env.PYPROJECT_FILE }}"
+          uv run .scripts/update_setup.py "${{ env.SETUP_FILE }}" "${{ env.AUTHORS_FILE }}" "${{ env.PYPROJECT_FILE }}"
           uvx ruff format
           git add "${{ env.SETUP_FILE }}"" "${{ env.PYPROJECT_FILE }}"
           git commit -m "Update supported Python versions"

-------------------------

Commit Hash: e22e3c4b4e59350840b43dc17927363714faad83
Commit Message: Fix license field
Diff: (1 files changed)
File changed: pyproject.toml
@@ -4,9 +4,9 @@ version = "0.18.1"
 description = "Ebook library which can handle EPUB2/EPUB3 format"
 readme = "README.md"
 requires-python = ">=3.6"
-license = "AGPL-3.0"
 keywords = ["ebook", "epub"]
 classifiers = [
+    "License :: OSI Approved :: GNU Affero General Public License v3",
     "Development Status :: 4 - Beta",
     "Intended Audience :: Developers",
     "Operating System :: OS Independent",

-------------------------

Commit Hash: 13c2facbe545d7562e7c9668f8cb334ecf7e580d
Commit Message: add license classifier
Diff: (1 files changed)
File changed: setup.py
@@ -24,6 +24,7 @@ setup(
     long_description_content_type="text/markdown",
     keywords=["ebook", "epub"],
     classifiers=[
+        "License :: OSI Approved :: GNU Affero General Public License v3",
         "Development Status :: 4 - Beta",
         "Intended Audience :: Developers",
         "Operating System :: OS Independent",

-------------------------

Commit Hash: cbb0f7fa12745a9f5ca60f62a26f1fb85a291502
Commit Message: Use legacy license identifier
Diff: (1 files changed)
File changed: pyproject.toml
@@ -4,6 +4,7 @@ version = "0.18.1"
 description = "Ebook library which can handle EPUB2/EPUB3 format"
 readme = "README.md"
 requires-python = ">=3.6"
+license = {text = "GNU Affero General Public License v3"}
 keywords = ["ebook", "epub"]
 classifiers = [
     "License :: OSI Approved :: GNU Affero General Public License v3",

-------------------------

Commit Hash: 42431371b8f046aa18fa4cf080ea270a04860feb
Commit Message: Update heading levels
Diff: (1 files changed)
File changed: README.md
@@ -2,7 +2,7 @@
 
 This is a fork of the popular Ebooklib library that aims to keep a package updated with changes from the original codebase. Any changes to [https://github.com/aerkalov/ebooklib] are merged into this package on a weekly basis.
 
-# About EbookLib
+## About EbookLib
 
 EbookLib is a Python library for managing EPUB2/EPUB3 files. It's capable of reading and writing EPUB files programmatically.
 
@@ -16,9 +16,9 @@ Packages of EbookLib for GNU/Linux are available in [Debian](https://packages.de
 
 Sphinx documentation is generated from the templates in the docs/ directory and made available at <http://ebooklib.readthedocs.io>
 
-# Usage
+## Usage
 
-## Reading
+### Reading
 
 ```py
 import ebooklib
@@ -30,7 +30,7 @@ for image in book.get_items_of_type(ebooklib.ITEM_IMAGE):
     print(image)
 ```
 
-## Writing
+### Writing
 
 ```py
 from ebooklib import epub
@@ -101,10 +101,10 @@ book.spine = ["nav", c1]
 epub.write_epub("test.epub", book, {})
 ```
 
-# License
+## License
 
 EbookLib is licensed under the [AGPL license](LICENSE.txt).
 
-# Authors
+## Authors
 
 Full list of authors is in [AUTHORS.txt](AUTHORS.txt) file.

-------------------------

Commit Hash: d7ba78e2aab508bab4e5d764aa709478c2dd194e
Commit Message: Add setuptools configuration
Diff: (1 files changed)
File changed: pyproject.toml
@@ -72,3 +72,12 @@ Homepage = "https://github.com/aerkalov/ebooklib"
 workflow = [
     "tomlkit>=0.11.6",
 ]
+
+[build-system]
+requires = [
+    "setuptools>=75.8.2",
+]
+build-backend = "setuptools.build_meta"
+
+[tool.setuptools]
+license-files = []
\ No newline at end of file

-------------------------

Commit Hash: beb9bbb1eceec8e914b14dd7be35ddb77ff03058
Commit Message: Add missing six dependency
Diff: (2 files changed)
File changed: pyproject.toml
@@ -62,6 +62,7 @@ authors = [
 
 dependencies = [
     "lxml>=4.9.0",
+    "six>=1.16.0",
 ]
 
 [project.urls]
@@ -80,4 +81,4 @@ requires = [
 build-backend = "setuptools.build_meta"
 
 [tool.setuptools]
-license-files = []
\ No newline at end of file
+license-files = []

File changed: uv.lock

-------------------------

Commit Hash: ae7cd422f4465652fcacaac77620a67951b49d97
Commit Message: Qodo adds self
Diff: (1 files changed)
File changed: .gitignore
@@ -118,4 +118,5 @@ venv.bak/
 .idea/
 
 # VSCode
-.vscode/
\ No newline at end of file
+.vscode/
+.qodo

-------------------------

Commit Hash: 6d776f2ffdf8d646bc3ea05d86051c448d7a4d2a
Commit Message: Local path
Diff: (1 files changed)
File added: .github/workflows/local-sync.yml
@@ -0,0 +1,78 @@
+name: Process Local Changes
+
+on:
+  push:
+    branches:
+      - master
+  workflow_dispatch:
+
+permissions:
+  contents: write
+  id-token: write
+
+env:
+  VERSION_FILE: VERSION.txt
+  SETUP_FILE: setup.py
+  AUTHORS_FILE: AUTHORS.txt
+  PYPROJECT_FILE: pyproject.toml
+  README_FILE: README.md
+
+jobs:
+  process:
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+
+      - name: Set up Git user
+        run: |
+          git config --global user.name "github-actions[bot]"
+          git config --global user.email "github-actions[bot]@users.noreply.github.com"
+
+      - name: Read current version
+        id: fork_state
+        run: |
+          CURRENT_VERSION=$(grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' "${{ env.VERSION_FILE }}")
+          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
+
+      - name: Increment version
+        id: version
+        run: |
+          IFS='.' read -r MAJOR MINOR PATCH <<< "${{ steps.fork_state.outputs.current_version }}"
+          PATCH=$(($PATCH + 1))
+          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
+          sed -i "0,/${{ steps.fork_state.outputs.current_version }}/s//${NEW_VERSION}/" ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }}
+          sed -i "0,/${{ steps.fork_state.outputs.current_version }}/s//${NEW_VERSION}/" ${{ env.PYPROJECT_FILE }}
+          git add ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }} ${{ env.PYPROJECT_FILE }}
+          git commit -m "Auto-increment version to $NEW_VERSION"
+
+      - name: Install uv
+        uses: astral-sh/setup-uv@v5
+        with:
+          enable-cache: true
+
+      - name: "Set up Python"
+        uses: actions/setup-python@v5
+        with:
+          python-version: "3.12"
+
+      - name: Update supported Python versions in setup.py
+        run: |
+          uv run .scripts/update_setup.py "${{ env.SETUP_FILE }}" "${{ env.AUTHORS_FILE }}" "${{ env.PYPROJECT_FILE }}"
+          uvx ruff format
+          git add "${{ env.SETUP_FILE }}" "${{ env.PYPROJECT_FILE }}"
+          git commit -m "Update supported Python versions"
+
+      - name: Update README
+        run: |
+          uv run .scripts/update_readme.py "${{ env.README_FILE }}"
+          git add "${{ env.README_FILE }}"
+          git commit -m "Update README"
+
+      - name: Push changes
+        run: git push origin master
+
+      - name: Build and publish
+        run: |
+          uv build
+          uv publish

-------------------------

Commit Hash: 4b6215e964f318e078ed7e3f9354c534a59519fd
Commit Message: Update metadata
Diff: (2 files changed)
File changed: pyproject.toml
@@ -4,7 +4,7 @@ version = "0.18.1"
 description = "Ebook library which can handle EPUB2/EPUB3 format"
 readme = "README.md"
 requires-python = ">=3.6"
-license = {text = "GNU Affero General Public License v3"}
+license = "AGPL-3.0"
 keywords = ["ebook", "epub"]
 classifiers = [
     "License :: OSI Approved :: GNU Affero General Public License v3",

File changed: setup.py
@@ -1,41 +1,9 @@
 import io
 import re
-
 from setuptools import setup
 
-
 def read(path):
-    with io.open(path, mode="r", encoding="utf-8") as fd:
+    with io.open(path, mode='r', encoding='utf-8') as fd:
         content = fd.read()
-    # Convert Markdown links to reStructuredText links
-    return re.sub(r"\[([^]]+)\]\(([^)]+)\)", r"`\1 <\2>`_", content)
-
-
-setup(
-    name="EbookLib",
-    version="0.18.1",
-    author="Aleksandar Erkalovic",
-    author_email="aerkalov@gmail.com",
-    packages=["ebooklib", "ebooklib.plugins"],
-    url="https://github.com/aerkalov/ebooklib",
-    license="GNU Affero General Public License",
-    description="Ebook library which can handle EPUB2/EPUB3 format",
-    long_description=read("README.md"),
-    long_description_content_type="text/markdown",
-    keywords=["ebook", "epub"],
-    classifiers=[
-        "License :: OSI Approved :: GNU Affero General Public License v3",
-        "Development Status :: 4 - Beta",
-        "Intended Audience :: Developers",
-        "Operating System :: OS Independent",
-        "Programming Language :: Python :: 3.6",
-        "Programming Language :: Python :: 3.7",
-        "Programming Language :: Python :: 3.8",
-        "Programming Language :: Python :: 3.9",
-        "Programming Language :: Python :: 3.10",
-        "Programming Language :: Python :: 3.11",
-        "Programming Language :: Python :: 3.12",
-        "Topic :: Software Development :: Libraries :: Python Modules",
-    ],
-    install_requires=["lxml", "six"],
-)
+    return re.sub('\\[([^]]+)\\]\\(([^)]+)\\)', '`\\1 <\\2>`_', content)
+setup(name='EbookLib', version='0.18.1', author='Aleksandar Erkalovic', author_email='aerkalov@gmail.com', packages=['ebooklib', 'ebooklib.plugins'], url='https://github.com/aerkalov/ebooklib', license='GNU Affero General Public License', description='Ebook library which can handle EPUB2/EPUB3 format', long_description=read('README.md'), long_description_content_type='text/markdown', keywords=['ebook', 'epub'], classifiers=['License :: OSI Approved :: GNU Affero General Public License v3', 'Development Status :: 4 - Beta', 'Intended Audience :: Developers', 'Operating System :: OS Independent', 'Programming Language :: Python :: 3.6', 'Programming Language :: Python :: 3.7', 'Programming Language :: Python :: 3.8', 'Programming Language :: Python :: 3.9', 'Programming Language :: Python :: 3.10', 'Programming Language :: Python :: 3.11', 'Programming Language :: Python :: 3.12', 'Topic :: Software Development :: Libraries :: Python Modules'], install_requires=['lxml', 'six'])
\ No newline at end of file

-------------------------

Commit Hash: 2ba6ecdbac22bd9e9ffe296a128bfb8a86f4fe52
Commit Message: Use Python 3.13
Diff: (2 files changed)
File changed: .github/workflows/auto-update.yml
@@ -103,7 +103,7 @@ jobs:
         if: steps.upstream_changes.outputs.updated_version == 'true'
         uses: actions/setup-python@v5
         with:
-          python-version: "3.12"
+          python-version: "3.13"
 
       - name: Update supported Python versions in setup.py
         if: steps.upstream_changes.outputs.update_setup == 'true'

File changed: .github/workflows/local-sync.yml
@@ -54,7 +54,7 @@ jobs:
       - name: "Set up Python"
         uses: actions/setup-python@v5
         with:
-          python-version: "3.12"
+          python-version: "3.13"
 
       - name: Update supported Python versions in setup.py
         run: |

-------------------------

Commit Hash: 0883f6c7c35dac5c2e7e3027a4b71c5b3a1fe7f1
Commit Message: Update setuptools to current version
Diff: (1 files changed)
File changed: pyproject.toml
@@ -76,7 +76,7 @@ workflow = [
 
 [build-system]
 requires = [
-    "setuptools>=75.8.2",
+    "setuptools>=76",
 ]
 build-backend = "setuptools.build_meta"
 

-------------------------

Commit Hash: aa2ffe3aeac8302065b98b549c8238fe89a10230
Commit Message: replace setup.py with blank file
Diff: (1 files changed)
File changed: .scripts/update_setup.py
@@ -8,6 +8,7 @@
 import ast
 import re
 import sys
+import textwrap
 from collections.abc import Generator
 
 import requests
@@ -40,7 +41,7 @@ def convert_license(license: str) -> str:
     spdx_url = "https://raw.githubusercontent.com/spdx/license-list-data/refs/heads/main/json/licenses.json"
     license_data = fetch_license_data(spdx_url)
     if spdx_id := next(find_license_id(license, license_data)):
-        return spdx_id
+        return "{text = %s}" % spdx_id
     else:
         raise ValueError(f"License ID not found for '{license}'")
 
@@ -246,7 +247,7 @@ def update_pyproject(
         f.write(toml_text)
 
 
-def update_setup_config(
+def update_config(
     config: dict[str, str | list[str]], supported_versions: list[str]
 ) -> dict[str, str | list[str]]:
     """
@@ -264,6 +265,8 @@ def update_setup_config(
     python_section_added = False
 
     for classifier in classifiers:
+        if "License" in classifier:
+            continue
         if "Programming Language :: Python :: " not in classifier:
             new_classifiers.append(classifier)
             continue
@@ -289,22 +292,6 @@ def get_value(node: ast.AST) -> str | list[str]:
     return nodes[type(node)](node)
 
 
-def make_value(value: str | list[str]) -> ast.AST:
-    nodes = {
-        str: ast.Constant(value),
-        list: ast.List(
-            elts=[ast.Constant(value=x) for x in value], ctx=ast.Load()
-        ),
-    }
-    return nodes[type(value)]
-
-
-def make_call_value(id: str, value: str) -> ast.Call:
-    return ast.Call(
-        func=ast.Name(id=id, ctx=ast.Load()), args=[make_value(value)]
-    )
-
-
 def is_setup_call(node: ast.AST) -> bool:
     """
     Check if the node is a call to the `setup` function.
@@ -330,44 +317,35 @@ def extract_setup_keywords(ast_tree: ast.AST) -> dict[str, str | list[str]]:
     raise ValueError("setup() call not found")
 
 
-def build_setup_ast(
-    tree: ast.AST, config: dict[str, str | list[str]]
-) -> ast.AST:
-    """
-    Build a new AST for setup.py from config dictionary.
-    """
-    keywords = [
-        ast.keyword(arg=key, value=make_call_value("read", value))
-        if key == "long_description"
-        else ast.keyword(arg=key, value=make_value(value))
-        for key, value in config.items()
-    ]
-
-    for node in ast.walk(tree):
-        if is_setup_call(node):
-            node.value.keywords = keywords
-
-    return tree
-
-
-def update_setup(setup_file: str) -> dict[str, str | list[str]]:
+def update_keywords(setup_file: str) -> dict[str, str | list[str]]:
     with open(setup_file, "r") as f:
         tree = ast.parse(f.read())
 
     supported_versions = ["3.6", "3.7", "3.8", "3.9", "3.10", "3.11", "3.12"]
 
     keywords = extract_setup_keywords(tree)
-    updated_keywords = update_setup_config(keywords, supported_versions)
-    transformed_ast = build_setup_ast(tree, updated_keywords)
+    return update_config(keywords, supported_versions)
+
+
+def replace_setup(setup_file: str) -> None:
+    legacy_setup = textwrap.dedent("""\
+        from setuptools import setup
+
+        setup()
+    """).strip("\n")
 
     with open(setup_file, "w") as f:
-        f.write(ast.unparse(transformed_ast))
+        f.write(legacy_setup)
 
-    return updated_keywords
+
+def main(author_file: str, setup_file: str, pyproject_file: str) -> None:
+    authors = parse_authors(author_file)
+    keywords = update_keywords(setup_file)
+    sections = parse_setup(keywords)
+    update_pyproject(pyproject_file, sections, authors)
+    replace_setup(setup_file)
 
 
 if __name__ == "__main__":
-    keywords = update_setup(sys.argv[1])
-    authors = parse_authors(sys.argv[2])
-    sections = parse_setup(keywords)
-    update_pyproject(sys.argv[3], sections, authors)
+    _, setup_file, author_file, pyproject_file = sys.argv
+    main(author_file, setup_file, pyproject_file)

-------------------------

Commit Hash: 8bf795537617e0bf4a31b2c62381957907169abf
Commit Message: Update license format for script to update file to run
Diff: (1 files changed)
File changed: pyproject.toml
@@ -4,7 +4,7 @@ version = "0.18.1"
 description = "Ebook library which can handle EPUB2/EPUB3 format"
 readme = "README.md"
 requires-python = ">=3.6"
-license = "AGPL-3.0"
+license = {text ="AGPL-3.0"}
 keywords = ["ebook", "epub"]
 classifiers = [
     "License :: OSI Approved :: GNU Affero General Public License v3",

-------------------------

Commit Hash: 74403f8a5066dd7dc4dcec672db7dc4a92734664
Commit Message: Fix license string and exlcude non-package files
Diff: (1 files changed)
File changed: pyproject.toml
@@ -4,10 +4,9 @@ version = "0.18.1"
 description = "Ebook library which can handle EPUB2/EPUB3 format"
 readme = "README.md"
 requires-python = ">=3.6"
-license = {text ="AGPL-3.0"}
+license = { text = "AGPL-3.0" }
 keywords = ["ebook", "epub"]
 classifiers = [
-    "License :: OSI Approved :: GNU Affero General Public License v3",
     "Development Status :: 4 - Beta",
     "Intended Audience :: Developers",
     "Operating System :: OS Independent",
@@ -82,3 +81,7 @@ build-backend = "setuptools.build_meta"
 
 [tool.setuptools]
 license-files = []
+
+[tool.setuptools.packages.find]
+include = ["ebooklib*"]
+exclude = ["samples*", ".scripts*", "tests*"]

-------------------------

Commit Hash: 5c8b71c5bbdb35a0969ad45f2935dcef594de56b
Commit Message: replace setup.py
Diff: (1 files changed)
File changed: setup.py
@@ -1,9 +1,3 @@
-import io
-import re
 from setuptools import setup
 
-def read(path):
-    with io.open(path, mode='r', encoding='utf-8') as fd:
-        content = fd.read()
-    return re.sub('\\[([^]]+)\\]\\(([^)]+)\\)', '`\\1 <\\2>`_', content)
-setup(name='EbookLib', version='0.18.1', author='Aleksandar Erkalovic', author_email='aerkalov@gmail.com', packages=['ebooklib', 'ebooklib.plugins'], url='https://github.com/aerkalov/ebooklib', license='GNU Affero General Public License', description='Ebook library which can handle EPUB2/EPUB3 format', long_description=read('README.md'), long_description_content_type='text/markdown', keywords=['ebook', 'epub'], classifiers=['License :: OSI Approved :: GNU Affero General Public License v3', 'Development Status :: 4 - Beta', 'Intended Audience :: Developers', 'Operating System :: OS Independent', 'Programming Language :: Python :: 3.6', 'Programming Language :: Python :: 3.7', 'Programming Language :: Python :: 3.8', 'Programming Language :: Python :: 3.9', 'Programming Language :: Python :: 3.10', 'Programming Language :: Python :: 3.11', 'Programming Language :: Python :: 3.12', 'Topic :: Software Development :: Libraries :: Python Modules'], install_requires=['lxml', 'six'])
\ No newline at end of file
+setup()
\ No newline at end of file

-------------------------

Commit Hash: ec378a7362ec253f694c7dab37740c610bb4dc40
Commit Message: Check if updates are necessary before updating
Diff: (1 files changed)
File changed: .scripts/update_readme.py
@@ -3,9 +3,26 @@ import sys
 
 
 def update_readme(readme_file: str) -> None:
+    """
+    Updates README.md with new values and a preamble.
+
+    This function checks if updates are necessary, and if so, splits the
+    readme file into sections split at code-fenced blocks. At non-code fenced
+    sections, it increments the heading levels by one and removes the `and
+    kindle ` prefix.
+
+    It then joins the sections back together and writes the updated content
+    back to the file along with a preamble.
+
+    Args:
+        readme_file (str): The path to the README.md file.
+    """
     with open(readme_file, "r") as f:
         content: str = f.read()
 
+    if content.startswith("# EbookLib-autoupdate"):
+        return
+
     sections: list[str] = re.split(r"(```.*?```)", content, flags=re.DOTALL)
     updated_sections: list[str] = []
 

-------------------------

Commit Hash: 72eac89b2e0b7deb9fb38bcc858e50ab590dc5e2
Commit Message: rename file
Diff: (2 files changed)
File added: .scripts/update_packaging.py
@@ -0,0 +1,516 @@
+# /// script
+# dependencies = [
+#     "tomlkit",
+# ]
+# ///
+
+import ast
+import json
+import re
+import sys
+from collections.abc import Callable, Generator
+from enum import Enum
+from pathlib import Path
+from typing import Any, TypeAlias
+
+import tomlkit
+from tomlkit.items import Array, Table
+
+
+MIN_PY3_SUPPORTED_VERSION = 9
+MAX_PY3_SUPPORTED_VERSION = 12
+
+FORK_MAINTAINER = {"name": "Ashlynn Antrobus", "email": "ashlynn@prosepal.io"}
+
+LEGACY_SETUP = "from setuptools import setup\n\n\nsetup()\n"
+
+Configuration: TypeAlias = str | list[str] | dict[str, Any]
+PyProject: TypeAlias = dict[str, Configuration]
+
+
+class Format(Enum):
+    SETUP = 1
+    PYPROJECT = 2
+
+
+def replace_setup(setup_path: Path, legacy_setup: str = LEGACY_SETUP) -> None:
+    """Replace the existing setup.py file"""
+    with setup_path.open("w", encoding="utf-8") as f:
+        f.write(legacy_setup)
+
+
+def parse_authors(authors_path: Path) -> dict[str, str]:
+    """Parse the authors file and return a dictionary of names and emails."""
+    authors = {}
+    lines = [line.strip() for line in authors_path.read_text().splitlines()]
+
+    for line in lines:
+        if line.startswith("Listed"):
+            continue
+        name, email = line.split(" <") if "<" in line else (line, "")
+        authors[name] = email.strip(">")
+
+    return authors
+
+
+def create_inline_array(input_dict: dict[str, str]) -> Array:
+    """Creates a tomlkit array on inline tables for authors/maintainers"""
+    array = tomlkit.array()
+    for name, email in input_dict.items():
+        inline_table = tomlkit.inline_table()
+        inline_table.update(
+            {"name": name, "email": email} if email else {"name": name}
+        )
+        array.append(inline_table)
+
+    return array
+
+
+def update_classifiers(classifiers: list[str]) -> Array:
+    """Creates a tomlkit array of project classifiers"""
+    array = tomlkit.array()
+    array.extend(classifiers)
+    return array
+
+
+def update_dependencies(
+    requirements: list[str], proj_dependencies: list[str]
+) -> Array:
+    """
+    Creates a tomlkit array of project dependencies from existing dependencies
+    and requirements
+    """
+    array = tomlkit.array()
+    dependencies: dict[str, str] = {
+        re.split(r"[<>=!~]", dependency)[0].strip(): dependency
+        for dependency in proj_dependencies
+    }
+
+    array.extend(dependencies[package] for package in requirements)
+    return array
+
+
+def update_maintainers(
+    sections: dict[str, str | list[str]],
+    auto_maintainer: dict = FORK_MAINTAINER,
+) -> Array:
+    """Creates a tomlkit inline array of project maintainers"""
+    maintainers = {
+        auto_maintainer["name"]: auto_maintainer["email"],
+        sections["maintainer"]: sections["maintainer_email"],
+    }
+    return create_inline_array(maintainers)
+
+
+def update_py_version(classifiers: list[str]) -> str:
+    """Build the `requires_python` string"""
+    requires_python = min(
+        (
+            classifier.strip("Programming Language :: Python :: ")
+            for classifier in classifiers
+            if "Programming Language" in classifier
+        ),
+        key=lambda version: int(version.split(".")[1]),
+    )
+
+    return f">={requires_python}"
+
+
+def update_urls(proj_urls: Table, home_url: str) -> Table:
+    """Create a urls table from new homepage url and other existing urls"""
+    urls = tomlkit.table()
+    urls.add("Homepage", home_url)
+    for page, url in proj_urls.value.body:
+        if page != "Homepage":
+            urls.add(page, url)
+    return urls
+
+
+def update_table_item(
+    item: str, project: Table, sections: dict, authors: dict
+) -> Table:
+    """Returns the updated value for a project table item."""
+    match item:
+        case "authors":
+            value = create_inline_array(authors)
+        case "classifiers":
+            value = update_classifiers(sections["classifiers"])
+        case "dependencies":
+            value = update_dependencies(
+                sections.get(
+                    "dependencies",
+                    sections["install_requires"],
+                    project["dependencies"],
+                )
+            )
+        case "maintainers":
+            value = update_maintainers(sections)
+        case "requires-python":
+            value = sections.get(
+                "requires_python", update_py_version(sections["classifiers"])
+            )
+        case "urls":
+            value = sections.get(
+                "urls", update_urls(project["urls"], sections["url"])
+            )
+        case _:
+            value = sections.get(item)
+    if item in {"classifiers", "dependencies", "authors", "maintainers"}:
+        value.multiline(True)
+    return value
+
+
+def sort_project_table(
+    doc: tomlkit.TOMLDocument,
+    sections: dict[str, str | list],
+    authors: dict[str, str],
+) -> tomlkit.TOMLDocument:
+    order = [
+        "name",
+        "version",
+        "description",
+        "readme",
+        "requires-python",
+        "license",
+        "keywords",
+        "classifiers",
+        "maintainers",
+        "authors",
+        "nl",  # A blank line
+        "dependencies",
+        "urls",
+    ]
+
+    table = tomlkit.table()
+
+    for item in order:
+        if item == "nl":
+            table.add(tomlkit.nl())
+            continue
+        value = (
+            update_table_item(item, doc["project"], sections, authors)
+            or doc["project"][item]
+        )
+        table.raw_append(item, value)
+
+    doc["project"] = table
+
+    return doc
+
+
+def update_pyproject(
+    toml_path: Path,
+    sections: dict[str, str | list[str]],
+    authors: dict[str, str],
+) -> None:
+    """Updates pyproject.toml with new values."""
+    with open(toml_path, "r", encoding="utf-8") as f:
+        doc = tomlkit.load(f)
+
+    updated_doc = sort_project_table(doc, sections, authors)
+    toml_text = re.sub("\n{3,}", "\n\n", tomlkit.dumps(updated_doc))
+
+    with toml_path.open("w", encoding="utf-8") as f:
+        f.write(toml_text)
+
+
+def build_supported_versions_list(
+    min_version: int = MIN_PY3_SUPPORTED_VERSION,
+    max_version: int = MAX_PY3_SUPPORTED_VERSION,
+) -> list[str]:
+    """Build a list of supported Python versions."""
+    assert min_version <= max_version
+    return [f"3.{version}" for version in range(min_version, max_version + 1)]
+
+
+def find_license_id(
+    license_name: str, license_data: dict
+) -> Generator[str, None, None]:
+    """Yield a SPDX license ID for the given license name."""
+    licenses = license_data.get("licenses", [])
+    normalized_name = license_name.lower().strip()
+
+    yield from (
+        license["licenseId"]
+        for license in licenses
+        if license["name"].lower().startswith(normalized_name)
+    )
+
+
+def convert_license(license: str, license_data: dict) -> str:
+    """
+    Convert a license name to a SPDX license ID.
+
+    Return the first SPDX license ID found for the given license name or raise a ValueError.
+
+    Args:
+        license (str): The name of the license.
+        license_data (dict): The SPDX license JSON data.
+
+    Returns:
+        str: The SPDX license ID.
+    """
+    try:
+        spdx_id = next(find_license_id(license, license_data))
+        return "{text = %s}" % spdx_id
+    except StopIteration as e:
+        raise ValueError(f"License ID not found for '{license}'") from e
+
+
+def convert_long_description(long_description: str) -> str:
+    """
+    Return the file name from the `long_description` function call in the
+    setup.py AST.
+    """
+    return long_description.lstrip("read(").rstrip(")").strip("'\"")
+
+
+def get_value(node: ast.AST) -> str | list[str]:
+    """Helper function to convert AST nodes to Python values"""
+    match node:
+        case ast.Constant(value=value):
+            return value
+        case ast.List(elts=elts):
+            return [get_value(elt) for elt in elts]
+        case ast.Call(args=args):
+            return get_value(args[0])
+    raise ValueError(f"Unhandled AST node type: {type(node)}")
+
+
+def is_setup_call(node: ast.AST) -> bool:
+    """
+    Check if the node is a call to the `setup` function.
+    """
+    return (
+        hasattr(node, "value")
+        and hasattr(node.value, "func")
+        and hasattr(node.value.func, "id")
+        and node.value.func.id == "setup"
+    )
+
+
+def extract_setup_keywords(ast_tree: ast.AST) -> dict[str, str | list[str]]:
+    """
+    Extract keyword arguments and their values from the setup() call in an AST
+    """
+    for node in ast.walk(ast_tree):
+        if is_setup_call(node):
+            return {
+                keyword.arg: get_value(keyword.value)
+                for keyword in node.value.keywords
+            }
+    raise ValueError("setup() call not found")
+
+
+def parse_ast(setup_path: Path) -> dict[str, str | list[str]]:
+    """Parse the setup.py file and return the project configuration."""
+    tree = ast.parse(setup_path.read_text(encoding="utf-8"))
+
+    return extract_setup_keywords(tree)
+
+
+def parse_pyproject(pyproject_path: Path) -> dict[str, str | list[str]]:
+    """Parse the pyproject.toml file and return the project configuration."""
+    with open(pyproject_path, "r", encoding="utf-8") as f:
+        doc = tomlkit.load(f)
+    return doc["project"]
+
+
+class ProjectParser:
+    """Parser for Python project configuration files."""
+
+    MUTUAL_SECTIONS = [
+        "version",
+        "license",
+        "description",
+        "keywords",
+        "classifiers",
+    ]
+
+    FORMAT_SECTIONS = {
+        Format.SETUP_PY: [
+            "author",
+            "author_email",
+            "long_description",
+            "url",
+            "install_requires",
+        ],
+        Format.PYPROJECT_TOML: [
+            "authors",
+            "maintainers",
+            "readme",
+            "dependencies",
+            "requires_python",
+            "urls",
+        ],
+    }
+
+    def __init__(self, license_data: dict[str, Any]):
+        """
+        Initialize the project configuration parser.
+
+        Args:
+            license_data: dictionary of license information for conversion
+        """
+        self.license_data = license_data
+        self._transformers: dict[
+            str, Callable[[Configuration], Configuration]
+        ] = {
+            "description": self._transform_description,
+            "keywords": self._transform_keywords,
+            "classifiers": self._transform_classifiers,
+        }
+
+    @staticmethod
+    def detect_format(
+        setup_path: Path, legacy_setup_content: str = ""
+    ) -> Format:
+        """
+        Detect the configuration format based on setup.py content.
+
+        Args:
+            setup_path: Path to setup.py file
+            legacy_setup_content: Content of legacy setup.py that indicates pyproject usage
+
+        Returns:
+            Detected configuration format
+        """
+        content = setup_path.read_text(encoding="utf-8")
+        return (
+            Format.PYPROJECT
+            if content.strip() == legacy_setup_content
+            else Format.SETUP
+        )
+
+    def parse(
+        self, config_format: Format, setup_path: Path, pyproject_path: Path
+    ) -> PyProject:
+        """
+        Parse the project configuration based on the detected format.
+
+        Args:
+            config_format: The configuration format to use
+            setup_path: Path to setup.py file
+            pyproject_path: Path to pyproject.toml file
+
+        Returns:
+            Parsed and normalized project configuration
+        """
+        raw_config = (
+            parse_ast(setup_path)
+            if config_format == Format.SETUP_PY
+            else parse_pyproject(pyproject_path)
+        )
+
+        transformed_config = self._apply_transformations(raw_config)
+        return self._normalize_config(transformed_config, config_format)
+
+    def _apply_transformations(self, config: PyProject) -> PyProject:
+        """Apply transformations to configuration values."""
+        result = config.copy()
+
+        for key, transformer in self._transformers.items():
+            if key in result:
+                result[key] = transformer(result[key])
+
+        return result
+
+    def _normalize_config(
+        self, config: PyProject, format: Format
+    ) -> PyProject:
+        """
+        Normalize configuration to a consistent format regardless of source.
+
+        Args:
+            config: The configuration to normalize
+            source_format: The format the configuration came from
+
+        Returns:
+            Normalized configuration
+        """
+        sections: PyProject = {
+            keyword: config[keyword] for keyword in config
+        } | {
+            keyword: config[keyword]
+            for keyword in self.FORMAT_SECTIONS[format]
+        }
+
+        if format == Format.SETUP:
+            sections |= {
+                "readme": sections.pop("long_description"),
+                "license": convert_license(
+                    sections["license"], self.license_data
+                ),
+                "maintainer": sections.pop("author"),
+                "maintainer_email": sections.pop("author_email"),
+            }
+
+        return sections
+
+    def _transform_description(self, description: str) -> str:
+        """Transform the project description."""
+        return description.replace("and kindle ", "").replace(
+            "and Kindle ", ""
+        )
+
+    def _transform_keywords(self, _: Any) -> list[str]:
+        """Transform keywords."""
+        return ["ebook", "epub"]
+
+    def _transform_classifiers(self, classifiers: list[str]) -> list[str]:
+        """Transform Python classifiers."""
+        supported_versions = build_supported_versions_list()
+        new_classifiers = []
+        python_section_added = False
+
+        for classifier in classifiers:
+            if "License" in classifier:
+                continue
+            if "Programming Language :: Python :: " not in classifier:
+                new_classifiers.append(classifier)
+                continue
+            if python_section_added:
+                continue
+            python_section_added = True
+            new_classifiers.extend(
+                f"Programming Language :: Python :: {version}"
+                for version in supported_versions
+            )
+
+        return new_classifiers
+
+
+def main(
+    author_path: Path,
+    setup_path: Path,
+    pyproject_path: Path,
+    license_path: Path,
+) -> None:
+    """
+    Main function.
+
+    Args:
+        author_file (Path): Path to the authors file.
+        setup_file (Path): Path to the setup.py file.
+        pyproject_file (Path): Path to the pyproject.toml file.
+        license_file (Path): Path to the license file.
+    """
+    authors = parse_authors(author_path)
+
+    with license_path.open("r", encoding="utf-8") as f:
+        license_data = json.load(f)
+
+    parser = ProjectParser(license_data)
+    update_file = parser.detect_format(setup_path)
+    sections = parser.parse(update_file, setup_path, pyproject_path)
+    update_pyproject(pyproject_path, sections, authors)
+    replace_setup(setup_path)
+
+
+if __name__ == "__main__":
+    _, setup_file, author_file, pyproject_file, license_file = sys.argv
+    setup_path = Path(setup_file)
+    author_path = Path(author_file)
+    pyproject_path = Path(pyproject_file)
+    license_path = Path(license_file)
+    main(author_path, setup_path, pyproject_path, license_path)

.scripts/update_setup.py deleted
-------------------------

Commit Hash: 8d721e07730a88f191330c66da175e0c2bc1b91a
Commit Message: split logic into own script
Diff: (1 files changed)
File added: .scripts/download_license_data.py
@@ -0,0 +1,41 @@
+# /// script
+# dependencies = [
+#     "requests",
+# ]
+# ///
+import time
+import json
+
+import requests
+
+URL = "https://raw.githubusercontent.com/spdx/license-list-data/refs/heads/main/json/licenses.json"
+
+
+def download_file(url: str) -> dict:
+    """Download file at url"""
+    response = requests.get(url, timeout=10)
+    response.raise_for_status()  # Raise an error for HTTP issues
+    return response.json()
+
+
+def fetch_data(url: str, retry: int = 0) -> dict:
+    """Fetch the license JSON from the given URL with retries."""
+    try:
+        return download_file(url)
+    except requests.exceptions.RequestException as e:
+        if retry > 3:
+            exit(1, f"Failed to fetch data from {url}: {e}")
+        retry += 1
+        backoff = 2**retry
+        time.sleep(backoff)
+        return fetch_data(url, retry)
+
+
+def main() -> None:
+    data = fetch_data(URL)
+    with open("licenses.json", "w") as f:
+        json.dump(data, f)
+
+
+if __name__ == "__main__":
+    main()

-------------------------

Commit Hash: b6fc8a18e745f90c79c18ebba56ca3bd3988c472
Commit Message: create shared workflow
Diff: (1 files changed)
File added: .github/workflows/update-files.yml
@@ -0,0 +1,102 @@
+name: Update Files
+
+on:
+  workflow_call:
+    inputs:
+      updated_version:
+        required: true
+        type: boolean
+
+
+permissions:
+  contents: write
+  id-token: write
+
+env:
+  VERSION_FILE: VERSION.txt
+  SETUP_FILE: setup.py
+  AUTHORS_FILE: AUTHORS.txt
+  PYPROJECT_FILE: pyproject.toml
+  README_FILE: README.md
+
+jobs:
+  process:
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+
+      - name: Set up Git user
+        run: |
+          git config --global user.name "github-actions[bot]"
+          git config --global user.email "github-actions[bot]@users.noreply.github.com"
+
+      - name: Read current version
+        id: fork_state
+        run: |
+          CURRENT_VERSION=$(grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' "${{ env.VERSION_FILE }}")
+          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
+
+      - name: Increment version
+        id: version
+        run: |
+          IFS='.' read -r MAJOR MINOR PATCH <<< "${{ steps.fork_state.outputs.current_version }}"
+          PATCH=$(($PATCH + 1))
+          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
+          sed -i "0,/${{ steps.fork_state.outputs.current_version }}/s//${NEW_VERSION}/" ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }}
+          sed -i "0,/${{ steps.fork_state.outputs.current_version }}/s//${NEW_VERSION}/" ${{ env.PYPROJECT_FILE }}
+          git add ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }} ${{ env.PYPROJECT_FILE }}
+          git commit -m "Auto-increment version to $NEW_VERSION"
+
+      - name: Install uv
+        uses: astral-sh/setup-uv@v5
+        with:
+          enable-cache: true
+
+      - name: "Set up Python"
+        uses: actions/setup-python@v5
+        with:
+          python-version: "3.13"
+
+      - name: Download license artifact
+        id: license-artifact
+        uses: actions/download-artifact@v3
+        continue-on-error: true
+        with:
+          name: license-data
+          path: ./scripts/license-data
+
+      - name: Download license data
+        if: steps.license-artifact.outcome == 'failure'
+        run: uv run .scripts/download_license_data.py
+
+      - name: Upload license artifact
+        if: steps.license-artifact.outcome == 'failure'
+        uses: actions/upload-artifact@v3
+        with:
+          name: license-data
+          path: ./scripts/license-data
+
+      - name: Add license data to env
+        run: echo "LICENSE_DATA=$(pwd)/scripts/license-data" >> $GITHUB_ENV
+
+      - name: Update packaging
+        run: |
+          uv run .scripts/update_packaging.py "${{ env.SETUP_FILE }}" "${{ env.AUTHORS_FILE }}" "${{ env.PYPROJECT_FILE }}" "${{ env.LICENSE_DATA }}"
+          uvx ruff format
+          git add "${{ env.SETUP_FILE }}" "${{ env.PYPROJECT_FILE }}"
+          git commit -m "Update supported Python versions"
+
+      - name: Update README
+        run: |
+          uv run .scripts/update_readme.py "${{ env.README_FILE }}"
+          git add "${{ env.README_FILE }}"
+          git commit -m "Update README"
+
+      - name: Push changes
+        run: git push origin master
+
+      - name: Build and publish
+        run: |
+          uv build
+          uv publish

-------------------------

Commit Hash: 0e039731e764b0ec9855a6e977b4164962367d00
Commit Message: apply shared workflow
Diff: (2 files changed)
File changed: .github/workflows/auto-update.yml
@@ -11,10 +11,6 @@ permissions:
 
 env:
   VERSION_FILE: VERSION.txt
-  SETUP_FILE: setup.py
-  AUTHORS_FILE: AUTHORS.txt
-  PYPROJECT_FILE: pyproject.toml
-  README_FILE: README.md
 
 jobs:
   update:
@@ -43,92 +39,25 @@ jobs:
         id: upstream_changes
         run: |
           VERSION_TIMESTAMP=$(git log -1 --format=%at -- ${{ env.VERSION_FILE }})
-          UPSTREAM_SETUP_TIMESTAMP=$(git log upstream/master -1 --format=%at -- ${{ env.SETUP_FILE }})
-          UPSTREAM_README_TIMESTAMP=$(git log upstream/master -1 --format=%at -- ${{ env.README_FILE }})
           if [[ $(git log upstream/master -1 --format=%at) -gt $VERSION_TIMESTAMP ]]; then
             echo "updated_version=true" >> $GITHUB_OUTPUT
           else
             echo "updated_version=false" >> $GITHUB_OUTPUT
           fi
-          if [[ $UPSTREAM_SETUP_TIMESTAMP -gt $VERSION_TIMESTAMP ]]; then
-            echo "update_setup=true" >> $GITHUB_OUTPUT
-          else
-            echo "update_setup=false" >> $GITHUB_OUTPUT
-          fi
-          if [[ $UPSTREAM_README_TIMESTAMP -gt $VERSION_TIMESTAMP ]]; then
-            echo "update_readme=true" >> $GITHUB_OUTPUT
-          else
-            echo "update_readme=false" >> $GITHUB_OUTPUT
-          fi
 
       - name: Merge upstream changes
         if: steps.upstream_changes.outputs.updated_version == 'true'
         run: |
           {
             echo "${{ env.VERSION_FILE }} merge=theirs"
-            if [[ "${{ steps.upstream_changes.outputs.update_setup }}" == "true" ]]; then
-              echo "${{ env.SETUP_FILE }} merge=theirs"
-            else
-              echo "${{ env.SETUP_FILE }} merge=ours"
-            fi
           } > .gitattributes
           git merge upstream/master --no-edit
 
-      - name: Increment version
-        id: version
+      - name: Update files
         if: steps.upstream_changes.outputs.updated_version == 'true'
-        run: |
-          UPSTREAM_VERSION=$(grep -Eo '[0-9]+\.[0-9]+' "${{ env.VERSION_FILE }}")
-          IFS='.' read -r UPSTREAM_MAJOR UPSTREAM_MINOR <<< "$UPSTREAM_VERSION"
-          CURRENT_VERSION="${{ steps.fork_state.outputs.current_version }}"
-          IFS='.' read -r CURRENT_MAJOR CURRENT_MINOR PATCH <<< "$CURRENT_VERSION"
-          if [[ $UPSTREAM_MAJOR == $CURRENT_MAJOR && $UPSTREAM_MINOR == $CURRENT_MINOR ]]; then
-            PATCH=$(($PATCH + 1))
-            NEW_VERSION="$CURRENT_MAJOR.$CURRENT_MINOR.$PATCH"
-          else
-            NEW_VERSION="$UPSTREAM_MAJOR.$UPSTREAM_MINOR.0"
-          fi
-          sed -i "0,/$UPSTREAM_VERSION/s//$NEW_VERSION/" ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }}
-          sed -i "0,/$CURRENT_VERSION/s//$NEW_VERSION" ${{ env.PYPROJECT_FILE }}
-          git add ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }} ${{ env.PYPROJECT_FILE }}
-          git commit -m "Auto-increment version to $NEW_VERSION"
-
-      - name: Install uv
-        if: steps.upstream_changes.outputs.updated_version == 'true'
-        uses: astral-sh/setup-uv@v5
+        uses: ./.github/workflows/update-files.yml
         with:
-          enable-cache: true
-
-      - name: "Set up Python"
-        if: steps.upstream_changes.outputs.updated_version == 'true'
-        uses: actions/setup-python@v5
-        with:
-          python-version: "3.13"
-
-      - name: Update supported Python versions in setup.py
-        if: steps.upstream_changes.outputs.update_setup == 'true'
-        run: |
-          uv run .scripts/update_setup.py "${{ env.SETUP_FILE }}" "${{ env.AUTHORS_FILE }}" "${{ env.PYPROJECT_FILE }}"
-          uvx ruff format
-          git add "${{ env.SETUP_FILE }}"" "${{ env.PYPROJECT_FILE }}"
-          git commit -m "Update supported Python versions"
-
-      - name: Update README
-        if: steps.upstream_changes.outputs.update_readme == 'true'
-        run: |
-          python .scripts/update_readme.py "${{ env.README_FILE }}"
-          git add "${{ env.README_FILE }}"
-          git commit -m "Update README"
-
-      - name: Push changes to fork
-        if: steps.upstream_changes.outputs.updated_version == 'true'
-        run: git push origin master
-
-      - name: Build and publish
-        if: steps.upstream_changes.outputs.updated_version == 'true'
-        run: |
-          uv build
-          uv publish
+          updated_version: ${{ steps.upstream_changes.outputs.updated_version }}
 
       - name: Sync new branches
         run: |

File changed: .github/workflows/local-sync.yml
@@ -6,73 +6,8 @@ on:
       - master
   workflow_dispatch:
 
-permissions:
-  contents: write
-  id-token: write
-
-env:
-  VERSION_FILE: VERSION.txt
-  SETUP_FILE: setup.py
-  AUTHORS_FILE: AUTHORS.txt
-  PYPROJECT_FILE: pyproject.toml
-  README_FILE: README.md
-
 jobs:
   process:
-    runs-on: ubuntu-latest
-    steps:
-      - name: Checkout
-        uses: actions/checkout@v4
-
-      - name: Set up Git user
-        run: |
-          git config --global user.name "github-actions[bot]"
-          git config --global user.email "github-actions[bot]@users.noreply.github.com"
-
-      - name: Read current version
-        id: fork_state
-        run: |
-          CURRENT_VERSION=$(grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' "${{ env.VERSION_FILE }}")
-          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
-
-      - name: Increment version
-        id: version
-        run: |
-          IFS='.' read -r MAJOR MINOR PATCH <<< "${{ steps.fork_state.outputs.current_version }}"
-          PATCH=$(($PATCH + 1))
-          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
-          sed -i "0,/${{ steps.fork_state.outputs.current_version }}/s//${NEW_VERSION}/" ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }}
-          sed -i "0,/${{ steps.fork_state.outputs.current_version }}/s//${NEW_VERSION}/" ${{ env.PYPROJECT_FILE }}
-          git add ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }} ${{ env.PYPROJECT_FILE }}
-          git commit -m "Auto-increment version to $NEW_VERSION"
-
-      - name: Install uv
-        uses: astral-sh/setup-uv@v5
-        with:
-          enable-cache: true
-
-      - name: "Set up Python"
-        uses: actions/setup-python@v5
-        with:
-          python-version: "3.13"
-
-      - name: Update supported Python versions in setup.py
-        run: |
-          uv run .scripts/update_setup.py "${{ env.SETUP_FILE }}" "${{ env.AUTHORS_FILE }}" "${{ env.PYPROJECT_FILE }}"
-          uvx ruff format
-          git add "${{ env.SETUP_FILE }}" "${{ env.PYPROJECT_FILE }}"
-          git commit -m "Update supported Python versions"
-
-      - name: Update README
-        run: |
-          uv run .scripts/update_readme.py "${{ env.README_FILE }}"
-          git add "${{ env.README_FILE }}"
-          git commit -m "Update README"
-
-      - name: Push changes
-        run: git push origin master
-
-      - name: Build and publish
-        run: |
-          uv build
-          uv publish
+    uses: ./.github/workflows/update-files.yml
+    with:
+      updated_version: true
\ No newline at end of file

-------------------------

Commit Hash: 1be5640c1300de9babb3733ec6f6596c88c36a71
Commit Message: remove uneeded dependency
Diff: (1 files changed)
File changed: pyproject.toml
@@ -68,10 +68,6 @@ dependencies = [
 Homepage = "https://github.com/aerkalov/ebooklib"
 "Documentation" = "https://ebooklib.readthedocs.io"
 
-[dependency-groups]
-workflow = [
-    "tomlkit>=0.11.6",
-]
 
 [build-system]
 requires = [

-------------------------

Commit Hash: a3848d3087a1d904ec0a40aa056ad863f769ab51
Commit Message: Provide permissions
Diff: (1 files changed)
File changed: .github/workflows/local-sync.yml
@@ -6,6 +6,10 @@ on:
       - master
   workflow_dispatch:
 
+permissions:
+  contents: write
+  id-token: write
+
 jobs:
   process:
     uses: ./.github/workflows/update-files.yml

-------------------------

Commit Hash: 3ec5ae75274eba2994fa6f24c078c3f0178032d6
Commit Message: Rename job
Diff: (1 files changed)
File changed: .github/workflows/local-sync.yml
@@ -11,7 +11,7 @@ permissions:
   id-token: write
 
 jobs:
-  process:
+  update-files:
     uses: ./.github/workflows/update-files.yml
     with:
       updated_version: true
\ No newline at end of file

-------------------------

Commit Hash: 02f3f86c89ee23dfef674553d0079e9bdc3669cf
Commit Message: Fix download-artifact version
Diff: (1 files changed)
File changed: .github/workflows/update-files.yml
@@ -20,7 +20,7 @@ env:
   README_FILE: README.md
 
 jobs:
-  process:
+  update-files:
     runs-on: ubuntu-latest
     steps:
       - name: Checkout
@@ -60,7 +60,7 @@ jobs:
 
       - name: Download license artifact
         id: license-artifact
-        uses: actions/download-artifact@v3
+        uses: actions/download-artifact@v4
         continue-on-error: true
         with:
           name: license-data

-------------------------

Commit Hash: 0b5dc96480ec80c3d5ea1d6bd5c39bf97fd51f11
Commit Message: fix action version number
Diff: (1 files changed)
File changed: .github/workflows/update-files.yml
@@ -72,7 +72,7 @@ jobs:
 
       - name: Upload license artifact
         if: steps.license-artifact.outcome == 'failure'
-        uses: actions/upload-artifact@v3
+        uses: actions/upload-artifact@v4
         with:
           name: license-data
           path: ./scripts/license-data

-------------------------

Commit Hash: 828122cdc501dec7c2cec66d1a6a7b3f9de2efec
Commit Message: Fix update_dependencies call
Diff: (1 files changed)
File changed: .scripts/update_packaging.py
@@ -136,9 +136,10 @@ def update_table_item(
         case "classifiers":
             value = update_classifiers(sections["classifiers"])
         case "dependencies":
-            value = update_dependencies(
-                sections.get(
-                    "dependencies",
+            value = (
+                update_dependencies("", sections.get("dependencies"))
+                if sections.get("dependencies")
+                else update_dependencies(
                     sections["install_requires"],
                     project["dependencies"],
                 )
@@ -328,14 +329,14 @@ class ProjectParser:
     ]
 
     FORMAT_SECTIONS = {
-        Format.SETUP_PY: [
+        Format.SETUP: [
             "author",
             "author_email",
             "long_description",
             "url",
             "install_requires",
         ],
-        Format.PYPROJECT_TOML: [
+        Format.PYPROJECT: [
             "authors",
             "maintainers",
             "readme",
@@ -398,7 +399,7 @@ class ProjectParser:
         """
         raw_config = (
             parse_ast(setup_path)
-            if config_format == Format.SETUP_PY
+            if config_format == Format.SETUP
             else parse_pyproject(pyproject_path)
         )
 

-------------------------

Commit Hash: a00f0f95d6fa7122b40ac809afe9e9976b9b6412
Commit Message: Fix minimum version check failing if Python 3 classifier exists
Diff: (1 files changed)
File changed: .scripts/update_packaging.py
@@ -10,6 +10,7 @@ import re
 import sys
 from collections.abc import Callable, Generator
 from enum import Enum
+from functools import cache
 from pathlib import Path
 from typing import Any, TypeAlias
 
@@ -33,6 +34,16 @@ class Format(Enum):
     PYPROJECT = 2
 
 
+@cache
+def build_supported_versions_list(
+    min_version: int = MIN_PY3_SUPPORTED_VERSION,
+    max_version: int = MAX_PY3_SUPPORTED_VERSION,
+) -> list[str]:
+    """Build a list of supported Python versions."""
+    assert min_version <= max_version
+    return [f"3.{version}" for version in range(min_version, max_version + 1)]
+
+
 def replace_setup(setup_path: Path, legacy_setup: str = LEGACY_SETUP) -> None:
     """Replace the existing setup.py file"""
     with setup_path.open("w", encoding="utf-8") as f:
@@ -102,16 +113,10 @@ def update_maintainers(
     return create_inline_array(maintainers)
 
 
-def update_py_version(classifiers: list[str]) -> str:
+def min_supported_py_version() -> str:
     """Build the `requires_python` string"""
-    requires_python = min(
-        (
-            classifier.strip("Programming Language :: Python :: ")
-            for classifier in classifiers
-            if "Programming Language" in classifier
-        ),
-        key=lambda version: int(version.split(".")[1]),
-    )
+    versions = build_supported_versions_list()
+    requires_python = min(versions)
 
     return f">={requires_python}"
 
@@ -147,9 +152,7 @@ def update_table_item(
         case "maintainers":
             value = update_maintainers(sections)
         case "requires-python":
-            value = sections.get(
-                "requires_python", update_py_version(sections["classifiers"])
-            )
+            value = sections.get("requires_python", min_supported_py_version())
         case "urls":
             value = sections.get(
                 "urls", update_urls(project["urls"], sections["url"])
@@ -215,15 +218,6 @@ def update_pyproject(
         f.write(toml_text)
 
 
-def build_supported_versions_list(
-    min_version: int = MIN_PY3_SUPPORTED_VERSION,
-    max_version: int = MAX_PY3_SUPPORTED_VERSION,
-) -> list[str]:
-    """Build a list of supported Python versions."""
-    assert min_version <= max_version
-    return [f"3.{version}" for version in range(min_version, max_version + 1)]
-
-
 def find_license_id(
     license_name: str, license_data: dict
 ) -> Generator[str, None, None]:

-------------------------

Commit Hash: 26a3ae427172f67e8823de4877969e48fbac8068
Commit Message: Wrap spdx id in quotes
Diff: (1 files changed)
File changed: .scripts/update_packaging.py
@@ -125,6 +125,9 @@ def update_urls(proj_urls: Table, home_url: str) -> Table:
     """Create a urls table from new homepage url and other existing urls"""
     urls = tomlkit.table()
     urls.add("Homepage", home_url)
+    if not proj_urls or proj_urls.value is None:
+        return urls
+
     for page, url in proj_urls.value.body:
         if page != "Homepage":
             urls.add(page, url)
@@ -247,7 +250,7 @@ def convert_license(license: str, license_data: dict) -> str:
     """
     try:
         spdx_id = next(find_license_id(license, license_data))
-        return "{text = %s}" % spdx_id
+        return '{text = "%s"}' % spdx_id
     except StopIteration as e:
         raise ValueError(f"License ID not found for '{license}'") from e
 

-------------------------

Commit Hash: 2aec9dae2a8db6c460f33cb86b1ec1b47e04f8a0
Commit Message: Update lock to remove unneeded dependencies
Diff: (1 files changed)
File changed: uv.lock

-------------------------

Commit Hash: a880475802c27fd0a1dcbafa3c61d761dd54a719
Commit Message: correct default parameter
Diff: (1 files changed)
File changed: .scripts/update_packaging.py
@@ -361,7 +361,7 @@ class ProjectParser:
 
     @staticmethod
     def detect_format(
-        setup_path: Path, legacy_setup_content: str = ""
+        setup_path: Path, legacy_setup_content: str = LEGACY_SETUP
     ) -> Format:
         """
         Detect the configuration format based on setup.py content.

-------------------------

Commit Hash: d59b587c5ee1116e01b9fde45085907322870a3f
Commit Message: Use Path for file operation
Diff: (1 files changed)
File changed: .scripts/download_license_data.py
@@ -5,6 +5,7 @@
 # ///
 import time
 import json
+from pathlib import Path
 
 import requests
 
@@ -32,9 +33,13 @@ def fetch_data(url: str, retry: int = 0) -> dict:
 
 
 def main() -> None:
+    file = Path(__file__).parent / "licenses.json"
     data = fetch_data(URL)
-    with open("licenses.json", "w") as f:
+    print(f"Downloaded {len(data)} licenses")
+    with file.open("w", encoding="utf-8") as f:
         json.dump(data, f)
+    if not file.exists():
+        exit(1, f"Failed to write license data to {file}")
 
 
 if __name__ == "__main__":

-------------------------

Commit Hash: 28069c814e75caacf4ca350b2da7f8660478944e
Commit Message: fix path to json file
Diff: (1 files changed)
File changed: .github/workflows/update-files.yml
@@ -75,10 +75,10 @@ jobs:
         uses: actions/upload-artifact@v4
         with:
           name: license-data
-          path: ./scripts/license-data
+          path: ./scripts/license-data.json
 
       - name: Add license data to env
-        run: echo "LICENSE_DATA=$(pwd)/scripts/license-data" >> $GITHUB_ENV
+        run: echo "LICENSE_DATA=$(pwd)/scripts/license-data.json" >> $GITHUB_ENV
 
       - name: Update packaging
         run: |

-------------------------

Commit Hash: d39b46a5b0bc911c8dac1daf0983f46f5e3bbc5e
Commit Message: Fix json path
Diff: (1 files changed)
File changed: .github/workflows/update-files.yml
@@ -75,10 +75,10 @@ jobs:
         uses: actions/upload-artifact@v4
         with:
           name: license-data
-          path: ./scripts/license-data.json
+          path: ./.scripts/license-data.json
 
       - name: Add license data to env
-        run: echo "LICENSE_DATA=$(pwd)/scripts/license-data.json" >> $GITHUB_ENV
+        run: echo "LICENSE_DATA=$(pwd)/.scripts/license-data.json" >> $GITHUB_ENV
 
       - name: Update packaging
         run: |

-------------------------

Commit Hash: 6b4a286e80d8837dcaabc6f1b6c2caa29f3f5b7a
Commit Message: Add logging of file save
Diff: (1 files changed)
File changed: .scripts/download_license_data.py
@@ -38,7 +38,9 @@ def main() -> None:
     print(f"Downloaded {len(data)} licenses")
     with file.open("w", encoding="utf-8") as f:
         json.dump(data, f)
-    if not file.exists():
+    if file.exists():
+        print(f"License data downloaded to {file.as_posix()}")
+    else:
         exit(1, f"Failed to write license data to {file}")
 
 

-------------------------

Commit Hash: 26ae5a27c3a79cddb18e8cf570c0225fd273c6f7
Commit Message: Fix json path
Diff: (1 files changed)
File changed: .scripts/download_license_data.py
@@ -33,7 +33,7 @@ def fetch_data(url: str, retry: int = 0) -> dict:
 
 
 def main() -> None:
-    file = Path(__file__).parent / "licenses.json"
+    file = Path(__file__).parent / "license-data.json"
     data = fetch_data(URL)
     print(f"Downloaded {len(data)} licenses")
     with file.open("w", encoding="utf-8") as f:

-------------------------

Commit Hash: 5a58b136f5e5972ed03ef8fe3e55548da43e09bb
Commit Message: Fix format detection
Diff: (2 files changed)
File changed: .scripts/update_packaging.py
@@ -30,8 +30,8 @@ PyProject: TypeAlias = dict[str, Configuration]
 
 
 class Format(Enum):
-    SETUP = 1
-    PYPROJECT = 2
+    SETUP = "setup.py"
+    PYPROJECT = "pyproject.toml"
 
 
 @cache
@@ -500,6 +500,8 @@ def main(
 
     parser = ProjectParser(license_data)
     update_file = parser.detect_format(setup_path)
+    print(f"Detected format: {update_file.value}")
+
     sections = parser.parse(update_file, setup_path, pyproject_path)
     update_pyproject(pyproject_path, sections, authors)
     replace_setup(setup_path)

File changed: setup.py
@@ -1,3 +1,4 @@
 from setuptools import setup
 
-setup()
\ No newline at end of file
+
+setup()

-------------------------

Commit Hash: 868593b210a31ce6c55ec8397cc5f068f4dac826
Commit Message: Strip newline from both sides in setup file comparisions
Diff: (1 files changed)
File changed: .scripts/update_packaging.py
@@ -376,7 +376,7 @@ class ProjectParser:
         content = setup_path.read_text(encoding="utf-8")
         return (
             Format.PYPROJECT
-            if content.strip() == legacy_setup_content
+            if content.strip() == legacy_setup_content.strip()
             else Format.SETUP
         )
 

-------------------------

Commit Hash: 71efeb464be82b0e4e6686e8d53041b62dd8b145
Commit Message: fix json path in download artifact workflow
Diff: (1 files changed)
File changed: .github/workflows/update-files.yml
@@ -64,7 +64,7 @@ jobs:
         continue-on-error: true
         with:
           name: license-data
-          path: ./scripts/license-data
+          path: ./.scripts/license-data.json
 
       - name: Download license data
         if: steps.license-artifact.outcome == 'failure'

-------------------------

Commit Hash: c805449aa667c2cd0d4787a3f84f4c11f3c11e39
Commit Message: fix requires-python key
Diff: (1 files changed)
File changed: .scripts/update_packaging.py
@@ -155,7 +155,7 @@ def update_table_item(
         case "maintainers":
             value = update_maintainers(sections)
         case "requires-python":
-            value = sections.get("requires_python", min_supported_py_version())
+            value = sections.get("requires-python", min_supported_py_version())
         case "urls":
             value = sections.get(
                 "urls", update_urls(project["urls"], sections["url"])
@@ -318,6 +318,7 @@ class ProjectParser:
     """Parser for Python project configuration files."""
 
     MUTUAL_SECTIONS = [
+        "name",
         "version",
         "license",
         "description",
@@ -338,7 +339,7 @@ class ProjectParser:
             "maintainers",
             "readme",
             "dependencies",
-            "requires_python",
+            "requires-python",
             "urls",
         ],
     }

-------------------------

Commit Hash: 133a9f4b1695ff4daa126b9060add040922bf7a3
Commit Message: Switch from artifacts to cache
Diff: (1 files changed)
File changed: .github/workflows/update-files.yml
@@ -58,24 +58,23 @@ jobs:
         with:
           python-version: "3.13"
 
-      - name: Download license artifact
-        id: license-artifact
-        uses: actions/download-artifact@v4
-        continue-on-error: true
+      - name: Restore license data from cache
+        id: license-cache
+        uses: actions/cache@v4
         with:
-          name: license-data
           path: ./.scripts/license-data.json
+          key: license-data
 
       - name: Download license data
-        if: steps.license-artifact.outcome == 'failure'
+        if: steps.license-cache.outputs.cache-hit != 'true'
         run: uv run .scripts/download_license_data.py
 
-      - name: Upload license artifact
-        if: steps.license-artifact.outcome == 'failure'
-        uses: actions/upload-artifact@v4
+      - name: Cache license data
+        if: steps.license-cache.outputs.cache-hit != 'true'
+        uses: actions/cache@v4
         with:
-          name: license-data
           path: ./.scripts/license-data.json
+          key: license-data
 
       - name: Add license data to env
         run: echo "LICENSE_DATA=$(pwd)/.scripts/license-data.json" >> $GITHUB_ENV

-------------------------

Commit Hash: af1ff88acb21a868883549d909c1386934cfcbff
Commit Message: Fix update_maintainers
Diff: (1 files changed)
File changed: .scripts/update_packaging.py
@@ -68,7 +68,7 @@ def create_inline_array(input_dict: dict[str, str]) -> Array:
     """Creates a tomlkit array on inline tables for authors/maintainers"""
     array = tomlkit.array()
     for name, email in input_dict.items():
-        inline_table = tomlkit.inline_table()
+        inline_table: tomlkit.items.InlineTable = tomlkit.inline_table()
         inline_table.update(
             {"name": name, "email": email} if email else {"name": name}
         )
@@ -102,13 +102,20 @@ def update_dependencies(
 
 
 def update_maintainers(
-    sections: dict[str, str | list[str]],
-    auto_maintainer: dict = FORK_MAINTAINER,
+    section_maintainers: dict[str, str],
+    project_maintainers: Array,
+    fork_maintainer: dict[str, str] = FORK_MAINTAINER,
 ) -> Array:
     """Creates a tomlkit inline array of project maintainers"""
+    if section_maintainers == project_maintainers:
+        if fork_maintainer not in project_maintainers:
+            maintainer = create_inline_array(fork_maintainer)
+            project_maintainers.extend(maintainer)
+        return project_maintainers
+
     maintainers = {
-        auto_maintainer["name"]: auto_maintainer["email"],
-        sections["maintainer"]: sections["maintainer_email"],
+        fork_maintainer["name"]: fork_maintainer["email"],
+        section_maintainers["name"]: section_maintainers["email"],
     }
     return create_inline_array(maintainers)
 
@@ -135,7 +142,7 @@ def update_urls(proj_urls: Table, home_url: str) -> Table:
 
 
 def update_table_item(
-    item: str, project: Table, sections: dict, authors: dict
+    item: str, project: Table, sections: PyProject, authors: dict[str, str]
 ) -> Table:
     """Returns the updated value for a project table item."""
     match item:
@@ -153,7 +160,9 @@ def update_table_item(
                 )
             )
         case "maintainers":
-            value = update_maintainers(sections)
+            value = update_maintainers(
+                sections["maintainers"], project["maintainers"]
+            )
         case "requires-python":
             value = sections.get("requires-python", min_supported_py_version())
         case "urls":
@@ -169,7 +178,7 @@ def update_table_item(
 
 def sort_project_table(
     doc: tomlkit.TOMLDocument,
-    sections: dict[str, str | list],
+    sections: PyProject,
     authors: dict[str, str],
 ) -> tomlkit.TOMLDocument:
     order = [
@@ -207,12 +216,12 @@ def sort_project_table(
 
 def update_pyproject(
     toml_path: Path,
-    sections: dict[str, str | list[str]],
+    sections: PyProject,
     authors: dict[str, str],
 ) -> None:
     """Updates pyproject.toml with new values."""
     with open(toml_path, "r", encoding="utf-8") as f:
-        doc = tomlkit.load(f)
+        doc: Table = tomlkit.load(f)
 
     updated_doc = sort_project_table(doc, sections, authors)
     toml_text = re.sub("\n{3,}", "\n\n", tomlkit.dumps(updated_doc))
@@ -307,11 +316,11 @@ def parse_ast(setup_path: Path) -> dict[str, str | list[str]]:
     return extract_setup_keywords(tree)
 
 
-def parse_pyproject(pyproject_path: Path) -> dict[str, str | list[str]]:
+def parse_pyproject(pyproject_path: Path) -> PyProject:
     """Parse the pyproject.toml file and return the project configuration."""
     with open(pyproject_path, "r", encoding="utf-8") as f:
         doc = tomlkit.load(f)
-    return doc["project"]
+    return doc["project"].unwrap()
 
 
 class ProjectParser:
@@ -440,7 +449,9 @@ class ProjectParser:
                 "license": convert_license(
                     sections["license"], self.license_data
                 ),
-                "maintainer": sections.pop("author"),
+                "maintainers": create_inline_array({
+                    sections["author"]: sections.pop("author")
+                }),
                 "maintainer_email": sections.pop("author_email"),
             }
 

-------------------------

Commit Hash: cc5378b1f683df921afa5a3b90c5e72242353231
Commit Message: pop url from sections
Diff: (1 files changed)
File changed: .scripts/update_packaging.py
@@ -169,6 +169,7 @@ def update_table_item(
             value = sections.get(
                 "urls", update_urls(project["urls"], sections["url"])
             )
+            sections.pop("url")
         case _:
             value = sections.get(item)
     if item in {"classifiers", "dependencies", "authors", "maintainers"}:

-------------------------

Commit Hash: 183e399fafa769c545657f37e86512227fbf7879
Commit Message: Fix key checks
Diff: (1 files changed)
File changed: .scripts/update_packaging.py
@@ -18,7 +18,7 @@ import tomlkit
 from tomlkit.items import Array, Table
 
 
-MIN_PY3_SUPPORTED_VERSION = 9
+MIN_PY3_SUPPORTED_VERSION = 6
 MAX_PY3_SUPPORTED_VERSION = 12
 
 FORK_MAINTAINER = {"name": "Ashlynn Antrobus", "email": "ashlynn@prosepal.io"}
@@ -68,6 +68,8 @@ def create_inline_array(input_dict: dict[str, str]) -> Array:
     """Creates a tomlkit array on inline tables for authors/maintainers"""
     array = tomlkit.array()
     for name, email in input_dict.items():
+        if not name:
+            continue
         inline_table: tomlkit.items.InlineTable = tomlkit.inline_table()
         inline_table.update(
             {"name": name, "email": email} if email else {"name": name}
@@ -102,7 +104,7 @@ def update_dependencies(
 
 
 def update_maintainers(
-    section_maintainers: dict[str, str],
+    section_maintainers: list[dict[str, str]],
     project_maintainers: Array,
     fork_maintainer: dict[str, str] = FORK_MAINTAINER,
 ) -> Array:
@@ -113,9 +115,10 @@ def update_maintainers(
             project_maintainers.extend(maintainer)
         return project_maintainers
 
+    section_maintainer = section_maintainers[0]
     maintainers = {
         fork_maintainer["name"]: fork_maintainer["email"],
-        section_maintainers["name"]: section_maintainers["email"],
+        section_maintainer["name"]: section_maintainer["email"],
     }
     return create_inline_array(maintainers)
 
@@ -143,7 +146,7 @@ def update_urls(proj_urls: Table, home_url: str) -> Table:
 
 def update_table_item(
     item: str, project: Table, sections: PyProject, authors: dict[str, str]
-) -> Table:
+) -> Configuration:
     """Returns the updated value for a project table item."""
     match item:
         case "authors":
@@ -166,10 +169,15 @@ def update_table_item(
         case "requires-python":
             value = sections.get("requires-python", min_supported_py_version())
         case "urls":
-            value = sections.get(
-                "urls", update_urls(project["urls"], sections["url"])
+            value = (
+                sections.get(
+                    "urls",
+                )
+                if sections.get("urls")
+                else update_urls(project.get("urls"), sections["url"])
             )
-            sections.pop("url")
+            if sections.get("url"):
+                sections.pop("url")
         case _:
             value = sections.get(item)
     if item in {"classifiers", "dependencies", "authors", "maintainers"}:
@@ -260,7 +268,9 @@ def convert_license(license: str, license_data: dict) -> str:
     """
     try:
         spdx_id = next(find_license_id(license, license_data))
-        return '{text = "%s"}' % spdx_id
+        license_table: tomlkit.items.InlineTable = tomlkit.inline_table()
+        license_table.update({"text": spdx_id})
+        return license_table
     except StopIteration as e:
         raise ValueError(f"License ID not found for '{license}'") from e
 
@@ -451,9 +461,8 @@ class ProjectParser:
                     sections["license"], self.license_data
                 ),
                 "maintainers": create_inline_array({
-                    sections["author"]: sections.pop("author")
+                    sections.pop("author"): sections.pop("author_email")
                 }),
-                "maintainer_email": sections.pop("author_email"),
             }
 
         return sections

-------------------------

Commit Hash: 1395bb2b25e35ceb3ea63eb9de974ba8f5a4acce
Commit Message: Restore untracked changes before push
Diff: (1 files changed)
File changed: .github/workflows/update-files.yml
@@ -93,7 +93,10 @@ jobs:
           git commit -m "Update README"
 
       - name: Push changes
-        run: git push origin master
+        run: |
+          git restore *
+          git push origin master
+
 
       - name: Build and publish
         run: |

-------------------------

Commit Hash: 7fe598d8b663fc0db41d5cb701e694b94f60c86e
Commit Message: Delete untracked license data after use
Diff: (1 files changed)
File changed: .github/workflows/update-files.yml
@@ -85,6 +85,7 @@ jobs:
           uvx ruff format
           git add "${{ env.SETUP_FILE }}" "${{ env.PYPROJECT_FILE }}"
           git commit -m "Update supported Python versions"
+          del ${{ env.LICENSE_DATA }}
 
       - name: Update README
         run: |

-------------------------

Commit Hash: cbd8d8ca711b280d60fe569f76cf7bded03e9ed1
Commit Message: Delete untracked license data after use
Diff: (1 files changed)
File changed: .github/workflows/update-files.yml
@@ -85,7 +85,7 @@ jobs:
           uvx ruff format
           git add "${{ env.SETUP_FILE }}" "${{ env.PYPROJECT_FILE }}"
           git commit -m "Update supported Python versions"
-          del ${{ env.LICENSE_DATA }}
+          rm ${{ env.LICENSE_DATA }}
 
       - name: Update README
         run: |

-------------------------

Commit Hash: 2de40ac7398a8054eae7ac6478c1d794833cb707
Commit Message: Check status before commit files
Diff: (1 files changed)
File changed: .github/workflows/update-files.yml
@@ -46,7 +46,9 @@ jobs:
           sed -i "0,/${{ steps.fork_state.outputs.current_version }}/s//${NEW_VERSION}/" ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }}
           sed -i "0,/${{ steps.fork_state.outputs.current_version }}/s//${NEW_VERSION}/" ${{ env.PYPROJECT_FILE }}
           git add ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }} ${{ env.PYPROJECT_FILE }}
-          git commit -m "Auto-increment version to $NEW_VERSION"
+          if git status --porcelain | grep -q -E "${{ env.VERSION_FILE }}|${{ env.SETUP_FILE }}|${{ env.PYPROJECT_FILE }}"; then
+            git commit -m "Auto-increment version to $NEW_VERSION"
+          fi
 
       - name: Install uv
         uses: astral-sh/setup-uv@v5
@@ -84,19 +86,28 @@ jobs:
           uv run .scripts/update_packaging.py "${{ env.SETUP_FILE }}" "${{ env.AUTHORS_FILE }}" "${{ env.PYPROJECT_FILE }}" "${{ env.LICENSE_DATA }}"
           uvx ruff format
           git add "${{ env.SETUP_FILE }}" "${{ env.PYPROJECT_FILE }}"
-          git commit -m "Update supported Python versions"
-          rm ${{ env.LICENSE_DATA }}
+          if git status --porcelain | grep -q -E "${{ env.SETUP_FILE }}|${{ env.PYPROJECT_FILE }}"; then
+            git commit -m "Update supported Python versions"
+          fi
+      - name: Remove license data
+        run: rm ${{ env.LICENSE_DATA }}
 
       - name: Update README
         run: |
           uv run .scripts/update_readme.py "${{ env.README_FILE }}"
           git add "${{ env.README_FILE }}"
-          git commit -m "Update README"
+          if git status --porcelain | grep -q "README.md"; then
+            git commit -m "Update README"
+          fi
 
       - name: Push changes
         run: |
           git restore *
-          git push origin master
+          if git log origin/master..HEAD | grep -q .; then
+            git push origin master
+          else
+            echo "No changes to push"
+          fi
 
 
       - name: Build and publish

-------------------------

Commit Hash: 471e87a0b39c6d7cc9be1466ce25606403be83da
Commit Message: Do not restore changes
Diff: (1 files changed)
File changed: .github/workflows/update-files.yml
@@ -102,7 +102,6 @@ jobs:
 
       - name: Push changes
         run: |
-          git restore *
           if git log origin/master..HEAD | grep -q .; then
             git push origin master
           else

-------------------------

Commit Hash: 57e88dd6e0a0b4c64c62218c53f1c00c4e91c176
Commit Message: Auto-increment version to 0.18.2
Diff: (2 files changed)
File changed: VERSION.txt
@@ -1 +1 @@
-EbookLib 0.18.1
+EbookLib 0.18.2

File changed: pyproject.toml
@@ -1,6 +1,6 @@
 [project]
 name = "ebooklib-autoupdate"
-version = "0.18.1"
+version = "0.18.2"
 description = "Ebook library which can handle EPUB2/EPUB3 format"
 readme = "README.md"
 requires-python = ">=3.6"

-------------------------

Commit Hash: 6dcceb7df8ab3a4504f8c70f7d5ba3d050ff1653
Commit Message: Update supported Python versions
Diff: (1 files changed)
File changed: pyproject.toml
@@ -4,7 +4,6 @@ version = "0.18.2"
 description = "Ebook library which can handle EPUB2/EPUB3 format"
 readme = "README.md"
 requires-python = ">=3.6"
-license = { text = "AGPL-3.0" }
 keywords = ["ebook", "epub"]
 classifiers = [
     "Development Status :: 4 - Beta",
@@ -58,16 +57,17 @@ authors = [
     {name = "Bono Lv", email = "lvscar@gmail.com"},
     {name = "Tom Ritchford", email = "tom@swirly.com"},
 ]
-
 dependencies = [
     "lxml>=4.9.0",
     "six>=1.16.0",
 ]
 
+[project.license]
+text = "AGPL-3.0"
+
 [project.urls]
 Homepage = "https://github.com/aerkalov/ebooklib"
-"Documentation" = "https://ebooklib.readthedocs.io"
-
+Documentation = "https://ebooklib.readthedocs.io"
 
 [build-system]
 requires = [

-------------------------

Commit Hash: 193638d0456bd22776a7dbff8b492637179f2ed3
Commit Message: Add parsing authors file
Diff: (8 files changed)
File changed: .github/workflows/auto-update.yml
@@ -12,6 +12,7 @@ permissions:
 env:
   VERSION_FILE: VERSION.txt
   SETUP_FILE: setup.py
+  AUTHORS_FILE: AUTHORS.txt
   PYPROJECT_FILE: pyproject.toml
   README_FILE: README.md
 
@@ -92,27 +93,31 @@ jobs:
           git add ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }} ${{ env.PYPROJECT_FILE }}
           git commit -m "Auto-increment version to $NEW_VERSION"
 
-          - name: Install uv
-          if: steps.upstream_changes.outputs.updated_version == 'true'
-          uses: astral-sh/setup-uv@v5
-          with:
-            enable-cache: true
+      - name: Install uv
+        if: steps.upstream_changes.outputs.updated_version == 'true'
+        uses: astral-sh/setup-uv@v5
+        with:
+          enable-cache: true
+
+      - name: "Set up Python"
+        if: steps.upstream_changes.outputs.updated_version == 'true'
+        uses: actions/setup-python@v5
+        with:
+          python-version: "3.13"
 
       - name: Update supported Python versions in setup.py
         if: steps.upstream_changes.outputs.update_setup == 'true'
         run: |
-          uv sync --group workflow
-          chmod +x .venv/bin/activate
-          ./.venv/bin/activate
-          /.venv/bin/python .scripts/update_setup.py "${{ env.SETUP_FILE }}" "${{ env.PYPROJECT_FILE }}"
-          git add ${{ env.SETUP_FILE }}
+          uv run .scripts/update_setup.py "${{ env.SETUP_FILE }}" "${{ env.AUTHORS_FILE }}" "${{ env.PYPROJECT_FILE }}"
+          uvx ruff format
+          git add "${{ env.SETUP_FILE }}"" "${{ env.PYPROJECT_FILE }}"
           git commit -m "Update supported Python versions"
 
       - name: Update README
         if: steps.upstream_changes.outputs.update_readme == 'true'
         run: |
           python .scripts/update_readme.py "${{ env.README_FILE }}"
-          git add ${{ env.README_FILE }}
+          git add "${{ env.README_FILE }}"
           git commit -m "Update README"
 
       - name: Push changes to fork

File added: .github/workflows/local-sync.yml
@@ -0,0 +1,78 @@
+name: Process Local Changes
+
+on:
+  push:
+    branches:
+      - master
+  workflow_dispatch:
+
+permissions:
+  contents: write
+  id-token: write
+
+env:
+  VERSION_FILE: VERSION.txt
+  SETUP_FILE: setup.py
+  AUTHORS_FILE: AUTHORS.txt
+  PYPROJECT_FILE: pyproject.toml
+  README_FILE: README.md
+
+jobs:
+  process:
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+
+      - name: Set up Git user
+        run: |
+          git config --global user.name "github-actions[bot]"
+          git config --global user.email "github-actions[bot]@users.noreply.github.com"
+
+      - name: Read current version
+        id: fork_state
+        run: |
+          CURRENT_VERSION=$(grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' "${{ env.VERSION_FILE }}")
+          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
+
+      - name: Increment version
+        id: version
+        run: |
+          IFS='.' read -r MAJOR MINOR PATCH <<< "${{ steps.fork_state.outputs.current_version }}"
+          PATCH=$(($PATCH + 1))
+          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
+          sed -i "0,/${{ steps.fork_state.outputs.current_version }}/s//${NEW_VERSION}/" ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }}
+          sed -i "0,/${{ steps.fork_state.outputs.current_version }}/s//${NEW_VERSION}/" ${{ env.PYPROJECT_FILE }}
+          git add ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }} ${{ env.PYPROJECT_FILE }}
+          git commit -m "Auto-increment version to $NEW_VERSION"
+
+      - name: Install uv
+        uses: astral-sh/setup-uv@v5
+        with:
+          enable-cache: true
+
+      - name: "Set up Python"
+        uses: actions/setup-python@v5
+        with:
+          python-version: "3.13"
+
+      - name: Update supported Python versions in setup.py
+        run: |
+          uv run .scripts/update_setup.py "${{ env.SETUP_FILE }}" "${{ env.AUTHORS_FILE }}" "${{ env.PYPROJECT_FILE }}"
+          uvx ruff format
+          git add "${{ env.SETUP_FILE }}" "${{ env.PYPROJECT_FILE }}"
+          git commit -m "Update supported Python versions"
+
+      - name: Update README
+        run: |
+          uv run .scripts/update_readme.py "${{ env.README_FILE }}"
+          git add "${{ env.README_FILE }}"
+          git commit -m "Update README"
+
+      - name: Push changes
+        run: git push origin master
+
+      - name: Build and publish
+        run: |
+          uv build
+          uv publish

File changed: .gitignore
@@ -118,4 +118,5 @@ venv.bak/
 .idea/
 
 # VSCode
-.vscode/
\ No newline at end of file
+.vscode/
+.qodo

File changed: .scripts/update_setup.py
@@ -1,27 +1,18 @@
 # /// script
 # dependencies = [
 #     "requests",
-#     "toml",
+#     "tomlkit",
 # ]
 # ///
 
+import ast
 import re
 import sys
 from collections.abc import Generator
 
 import requests
-import toml
-
-
-def create_author_line(sections: dict) -> str:
-    name = sections["author"]
-    email = sections["author_email"]
-
-    return "{ " + f"name = {name}, email = {email} " + "}"
-
-
-def convert_long_description(long_description: str) -> str:
-    return long_description.lstrip("read(").rstrip(")").strip("'\"")
+import tomlkit
+from tomlkit.items import Array, Table
 
 
 def fetch_license_data(url: str) -> dict:
@@ -54,118 +45,329 @@ def convert_license(license: str) -> str:
         raise ValueError(f"License ID not found for '{license}'")
 
 
-def parse_setup(setup_file: str) -> dict[str, str | list[str]]:
-    setup_sections = {
-        "author": str,
-        "author_email": str,
-        "url": str,
-        "license": str,
-        "description": str,
-        "long_description": str,
-        "keywords": list,
-        "classifiers": list,
-        "install_requires": list,
-    }
+def read_lines(file_path: str) -> Generator[str, None, None]:
+    """Returns a list of lines stripped of whitespace"""
+    with open(file_path, "r", encoding="utf-8") as file:
+        yield from (line for line in map(str.strip, file) if line)
 
-    sections: dict[str, str | list[str]] = {
-        key: [] if isinstance(val, list) else ""
-        for key, val in setup_sections.items()
-    }
 
-    with open(setup_file, "r") as file:
-        lines = [line.strip() for line in file]
-
-    lines = iter(lines)
-
-    key = ""
-    for line in lines:
-        if "=" in line:
-            key, value = (part.strip() for part in line.split("=", 1))
-            if key in setup_sections:
-                if value.startswith("["):
-                    sections[key] = []
-                    value = value.lstrip("[")
-                else:
-                    sections[key] = value.strip("\"'")
-
-        elif isinstance(sections.get(key), list):
-            if line == "]":
-                continue
-            sections[key].append(line.strip("\"'"))
-
-    sections["author"] = create_author_line(sections)
-    sections.pop("author_email")
-    sections["readme"] = convert_long_description(sections["long_description"])
-    sections.pop("long_description")
-    sections["license"] = convert_license(sections["license"])
+def parse_authors(authors_file: str) -> dict[str, str]:
+    """Parse the authors file and return a dictionary of names and emails."""
+    authors = {}
+
+    for line in read_lines(authors_file):
+        if line.startswith("Listed"):
+            continue
+        name, email = line.split(" <") if "<" in line else (line, "")
+        authors[name] = email.strip(">")
+
+    return authors
+
+
+def strip_string(string: str, chars: str = "\"',[]") -> str:
+    """Strip quotes, brackets, and commas from a string."""
+    return string.strip(chars)
+
+
+def convert_long_description(long_description: str) -> str:
+    return long_description.lstrip("read(").rstrip(")").strip("'\"")
+
+
+def parse_setup(
+    setup_keywords: dict[str, str | list[str]],
+) -> dict[str, str | list[str]]:
+    """Parse the setup.py file and return a dictionary of sections."""
+    setup_sections: list[str] = [
+        "version",
+        "author",
+        "author_email",
+        "url",
+        "license",
+        "description",
+        "long_description",
+        "keywords",
+        "classifiers",
+        "install_requires",
+    ]
+
+    sections = {keyword: setup_keywords[keyword] for keyword in setup_sections}
+
+    sections |= {
+        "readme": sections.pop("long_description"),
+        "license": convert_license(sections["license"]),
+        "maintainer": sections.pop("author"),
+        "maintainer_email": sections.pop("author_email"),
+    }
 
     return sections
 
 
-def update_pyproject(toml_file: str, sections: dict[str, str | list[str]]):
-    """Updates pyproject.toml with new values."""
-    with open(toml_file, "r") as f:
-        data = toml.load(f)
+def create_inline_array(input_dict: dict[str, str]) -> Array:
+    """Creates a tomlkit array on inline tables for authors/maintainers"""
+    array = tomlkit.array()
+    for name, email in input_dict.items():
+        inline_table = tomlkit.inline_table()
+        inline_table.update(
+            {"name": name, "email": email} if email else {"name": name}
+        )
+        array.append(inline_table)
+
+    return array
+
+
+def update_classifiers(classifiers: list[str]) -> Array:
+    """Creates a tomlkit array of project classifiers"""
+    array = tomlkit.array()
+    array.extend(classifiers)
+    return array
 
+
+def update_dependencies(
+    requirements: list[str], proj_dependencies: list[str]
+) -> Array:
+    """
+    Creates a tomlkit array of project dependencies from existing dependencies
+    and requirements
+    """
+    array = tomlkit.array()
     dependencies: dict[str, str] = {
         re.split(r"[<>=!~]", dependency)[0].strip(): dependency
-        for dependency in data["project"]["dependencies"]
+        for dependency in proj_dependencies
+    }
+
+    array.extend(dependencies[package] for package in requirements)
+    return array
+
+
+def update_maintainers(sections: dict[str, str | list[str]]) -> Array:
+    """Creates an array of project maintainers"""
+    maintainers = {
+        "Ashlynn Antrobus": "ashlynn@prosepal.io",
+        sections["maintainer"]: sections["maintainer_email"],
     }
+    return create_inline_array(maintainers)
+
 
+def update_py_version(classifiers: list[str]) -> str:
+    """Build the `requires_python` string"""
     requires_python = min(
-        classifier.strip("Programming Language :: Python :: ")
-        for classifier in sections["classifiers"]
-        if "Python" in classifier
+        (
+            classifier.strip("Programming Language :: Python :: ")
+            for classifier in classifiers
+            if "Programming Language" in classifier
+        ),
+        key=lambda version: int(version.split(".")[1]),
     )
 
-    data["project"]["requires-python"] = f">={requires_python}"
-
-    for key, value in sections.items():
-        if key == "install_requires":
-            for dependency in dependencies:
-                if dependency not in value:
-                    data["project"]["dependencies"].remove(
-                        dependencies[dependency]
-                    )
-        elif key == "url":
-            data["project"]["urls"]["Homepage"] = value
-        else:
-            data["project"][key] = value
+    return f">={requires_python}"
+
+
+def update_urls(proj_urls: Table, home_url: str) -> Table:
+    """Create a urls table from new homepage url and other existing urls"""
+    urls = tomlkit.table()
+    urls.add("Homepage", home_url)
+    for page, url in proj_urls.value.body:
+        if page != "Homepage":
+            urls.add(page, url)
+    return urls
+
+
+def update_table_item(
+    item: str, project: Table, sections: dict, authors: dict
+) -> Table:
+    """Returns the updated value for a project table item."""
+    handlers = {
+        "authors": lambda: create_inline_array(authors),
+        "classifiers": lambda: update_classifiers(sections["classifiers"]),
+        "dependencies": lambda: update_dependencies(
+            sections["install_requires"], project["dependencies"]
+        ),
+        "maintainers": lambda: update_maintainers(sections),
+        "requires-python": lambda: update_py_version(sections["classifiers"]),
+        "urls": lambda: update_urls(project["urls"], sections["url"]),
+    }
+    value = handlers.get(item, lambda: sections.get(item))()
+    if item in {"classifiers", "dependencies", "authors", "maintainers"}:
+        value.multiline(True)
+    return value
+
+
+def sort_project_table(
+    toml: tomlkit.TOMLDocument,
+    sections: dict[str, str | list],
+    authors: dict[str, str],
+) -> tomlkit.TOMLDocument:
+    order = [
+        "name",
+        "version",
+        "description",
+        "readme",
+        "requires-python",
+        "license",
+        "keywords",
+        "classifiers",
+        "maintainers",
+        "authors",
+        "nl",  # A blank line
+        "dependencies",
+        "urls",
+    ]
+
+    table = tomlkit.table()
+
+    for item in order:
+        if item == "nl":
+            table.add(tomlkit.nl())
+            continue
+        value = (
+            update_table_item(item, toml["project"], sections, authors)
+            or toml["project"][item]
+        )
+        table.raw_append(item, value)
+
+    toml["project"] = table
+
+    return toml
+
+
+def update_pyproject(
+    toml_file: str,
+    sections: dict[str, str | list[str]],
+    authors: dict[str, str],
+) -> None:
+    """Updates pyproject.toml with new values."""
+    with open(toml_file, "r", encoding="utf-8") as f:
+        doc = tomlkit.load(f)
 
-    with open(toml_file, "w") as f:
-        toml.dump(data, f)
+    updated_doc = sort_project_table(doc, sections, authors)
+    toml_text = re.sub("\n\n\n", "\n\n", tomlkit.dumps(updated_doc))
 
+    with open(toml_file, "w", encoding="utf-8") as f:
+        f.write(toml_text)
 
-def update_setup(setup_file) -> str:
-    supported_versions = ["3.6", "3.7", "3.8", "3.9", "3.10", "3.11", "3.12"]
 
-    with open(setup_file, "r") as f:
-        text = f.read()
+def update_setup_config(
+    config: dict[str, str | list[str]], supported_versions: list[str]
+) -> dict[str, str | list[str]]:
+    """
+    Update the setup configuration dictionary with new values.
+    """
+    description = config["description"]
+    config["description"] = description.replace("and kindle ", "").replace(
+        "and Kindle ", ""
+    )
 
-    text = text.replace("and kindle ", "")
+    config["keywords"] = ["ebook", "epub"]
+
+    classifiers = config["classifiers"]
+    new_classifiers = []
+    python_section_added = False
+
+    for classifier in classifiers:
+        if "Programming Language :: Python :: " not in classifier:
+            new_classifiers.append(classifier)
+            continue
+        if python_section_added:
+            continue
+        python_section_added = True
+        new_classifiers.extend(
+            f"Programming Language :: Python :: {version}"
+            for version in supported_versions
+        )
+
+    config["classifiers"] = new_classifiers
+    return config
+
+
+def get_value(node: ast.AST) -> str | list[str]:
+    """Helper function to convert AST nodes to Python values"""
+    nodes = {
+        ast.Constant: lambda n: n.value,
+        ast.List: lambda n: [get_value(elt) for elt in n.elts],
+        ast.Call: lambda n: get_value(n.args[0]),
+    }
+    return nodes[type(node)](node)
 
-    allowed_keywords = r"Keywords = ['ebook', 'epub']"
-    keyword_pattern = r"Keywords = [(?:'\w+',\s?)*'\w+']"
 
-    corrected_text = re.sub(keyword_pattern, allowed_keywords, text)
+def make_value(value: str | list[str]) -> ast.AST:
+    nodes = {
+        str: ast.Constant(value),
+        list: ast.List(
+            elts=[ast.Constant(value=x) for x in value], ctx=ast.Load()
+        ),
+    }
+    return nodes[type(value)]
 
-    programming_line_stub = '"Programming Language :: Python :: '
-    programming_line = f'{programming_line_stub}[0-9.]+,"'
 
-    old_versions = rf"^\s*{programming_line}*(?:\n\s*{programming_line})*"
-    new_versions = "\n".join(
-        f'         {programming_line_stub}{version},"'
-        for version in supported_versions
+def make_call_value(id: str, value: str) -> ast.Call:
+    return ast.Call(
+        func=ast.Name(id=id, ctx=ast.Load()), args=[make_value(value)]
     )
-    new_version_text = re.sub(
-        old_versions, new_versions, corrected_text, flags=re.MULTILINE
+
+
+def is_setup_call(node: ast.AST) -> bool:
+    """
+    Check if the node is a call to the `setup` function.
+    """
+    return (
+        hasattr(node, "value")
+        and hasattr(node.value, "func")
+        and hasattr(node.value.func, "id")
+        and node.value.func.id == "setup"
     )
 
+
+def extract_setup_keywords(ast_tree: ast.AST) -> dict[str, str | list[str]]:
+    """
+    Extract keyword arguments and their values from the setup() call in an AST
+    """
+    for node in ast.walk(ast_tree):
+        if is_setup_call(node):
+            return {
+                keyword.arg: get_value(keyword.value)
+                for keyword in node.value.keywords
+            }
+    raise ValueError("setup() call not found")
+
+
+def build_setup_ast(
+    tree: ast.AST, config: dict[str, str | list[str]]
+) -> ast.AST:
+    """
+    Build a new AST for setup.py from config dictionary.
+    """
+    keywords = [
+        ast.keyword(arg=key, value=make_call_value("read", value))
+        if key == "long_description"
+        else ast.keyword(arg=key, value=make_value(value))
+        for key, value in config.items()
+    ]
+
+    for node in ast.walk(tree):
+        if is_setup_call(node):
+            node.value.keywords = keywords
+
+    return tree
+
+
+def update_setup(setup_file: str) -> dict[str, str | list[str]]:
+    with open(setup_file, "r") as f:
+        tree = ast.parse(f.read())
+
+    supported_versions = ["3.6", "3.7", "3.8", "3.9", "3.10", "3.11", "3.12"]
+
+    keywords = extract_setup_keywords(tree)
+    updated_keywords = update_setup_config(keywords, supported_versions)
+    transformed_ast = build_setup_ast(tree, updated_keywords)
+
     with open(setup_file, "w") as f:
-        f.write(new_version_text)
+        f.write(ast.unparse(transformed_ast))
+
+    return updated_keywords
 
 
 if __name__ == "__main__":
-    update_setup(sys.argv[1])
-    sections = parse_setup(sys.argv[1])
-    update_pyproject(sys.argv[2], sections)
+    keywords = update_setup(sys.argv[1])
+    authors = parse_authors(sys.argv[2])
+    sections = parse_setup(keywords)
+    update_pyproject(sys.argv[3], sections, authors)

File changed: README.md
@@ -2,7 +2,7 @@
 
 This is a fork of the popular Ebooklib library that aims to keep a package updated with changes from the original codebase. Any changes to [https://github.com/aerkalov/ebooklib] are merged into this package on a weekly basis.
 
-# About EbookLib
+## About EbookLib
 
 EbookLib is a Python library for managing EPUB2/EPUB3 files. It's capable of reading and writing EPUB files programmatically.
 
@@ -16,9 +16,9 @@ Packages of EbookLib for GNU/Linux are available in [Debian](https://packages.de
 
 Sphinx documentation is generated from the templates in the docs/ directory and made available at <http://ebooklib.readthedocs.io>
 
-# Usage
+## Usage
 
-## Reading
+### Reading
 
 ```py
 import ebooklib
@@ -30,7 +30,7 @@ for image in book.get_items_of_type(ebooklib.ITEM_IMAGE):
     print(image)
 ```
 
-## Writing
+### Writing
 
 ```py
 from ebooklib import epub
@@ -101,10 +101,10 @@ book.spine = ["nav", c1]
 epub.write_epub("test.epub", book, {})
 ```
 
-# License
+## License
 
 EbookLib is licensed under the [AGPL license](LICENSE.txt).
 
-# Authors
+## Authors
 
 Full list of authors is in [AUTHORS.txt](AUTHORS.txt) file.

File changed: pyproject.toml
@@ -1,15 +1,13 @@
 [project]
 name = "ebooklib-autoupdate"
 version = "0.18.1"
-description = "Ebook library which can handle EPUB2/EPUB3"
+description = "Ebook library which can handle EPUB2/EPUB3 format"
 readme = "README.md"
 requires-python = ">=3.6"
-license = "AGPL-3.0-only"
-authors = [
-    { name = "Aleksandar Erkalovic", email = "aerkalov@gmail.com" }
-    ]
+license = "AGPL-3.0"
 keywords = ["ebook", "epub"]
 classifiers = [
+    "License :: OSI Approved :: GNU Affero General Public License v3",
     "Development Status :: 4 - Beta",
     "Intended Audience :: Developers",
     "Operating System :: OS Independent",
@@ -20,18 +18,67 @@ classifiers = [
     "Programming Language :: Python :: 3.10",
     "Programming Language :: Python :: 3.11",
     "Programming Language :: Python :: 3.12",
-    "Topic :: Software Development :: Libraries :: Python Modules"
+    "Topic :: Software Development :: Libraries :: Python Modules",
+]
+maintainers = [
+    {name = "Ashlynn Antrobus", email = "ashlynn@prosepal.io"},
+    {name = "Aleksandar Erkalovic", email = "aerkalov@gmail.com"},
+]
+authors = [
+    {name = "Aleksandar Erkalovic", email = "aerkalov@gmail.com"},
+    {name = "Borko Jandras", email = "bjandras@gmail.com"},
+    {name = "the-happy-hippo", email = "th3hh0@gmail.com"},
+    {name = "Daniel James", email = "daniel@64studio.com"},
+    {name = "Mikhail Gusarov", email = "dottedmag@dottedmag.net"},
+    {name = "Raymond Yee", email = "raymond.yee@gmail.com"},
+    {name = "Chris Grice", email = "chris@chrisgrice.com"},
+    {name = "Fernando Wime", email = "fernando.d@wime.com.mx"},
+    {name = "Andy Roberts", email = "andy.roberts.uk@gmail.com"},
+    {name = "Tom McLean", email = "tom.a.mclean@gmail.com"},
+    {name = "Travis L", email = "leleu@industrialinterface.com"},
+    {name = "Helmy Giacoman", email = "helmygb@gmail.com"},
+    {name = "clach04", email = "Chris.Clark@actian.com"},
+    {name = "Edward Betts", email = "edward@4angle.com"},
+    {name = "Kennyl", email = "Kennyl@users.noreply.github.com"},
+    {name = "Oleg Pshenichniy", email = "olegpshenichniy@gmail.com"},
+    {name = "Olivier Le Thanh Duong", email = "olivier@lethanh.be"},
+    {name = "Michael Storm", email = "mstorm7@gmail.com"},
+    {name = "Sergey Markelov"},
+    {name = "Laurent Laporte", email = "tantale.solutions@gmail.com"},
+    {name = "Deborah Kaplan", email = "deborahgu@users.noreply.github.com"},
+    {name = "Willem van der Walt", email = "wvdwalt@csir.co.za"},
+    {name = "Peter", email = "82152909+repeterat@users.noreply.github.com"},
+    {name = "u8slvn", email = "u8slvn@gmail.com"},
+    {name = "tugot17", email = "piotr635@gmail.com"},
+    {name = "张悦", email = "zhangyue@xtzx.com"},
+    {name = "Morphus", email = "mr.morphus@gmail.com"},
+    {name = "Kian-Meng, Ang", email = "kianmeng@cpan.org"},
+    {name = "Jared Wong", email = "jaredlwong@gmail.com"},
+    {name = "Michael Timblin", email = "mjtimblin@gmail.com"},
+    {name = "Hsiu-Ming Chang", email = "cges30901@gmail.com"},
+    {name = "Bono Lv", email = "lvscar@gmail.com"},
+    {name = "Tom Ritchford", email = "tom@swirly.com"},
 ]
+
 dependencies = [
     "lxml>=4.9.0",
-    "six>=1.0.0",
+    "six>=1.16.0",
 ]
 
 [project.urls]
-"Homepage" = "https://github.com/aleksandar-erkalovic/ebooklib"
+Homepage = "https://github.com/aerkalov/ebooklib"
 "Documentation" = "https://ebooklib.readthedocs.io"
 
 [dependency-groups]
 workflow = [
-    "toml>=0.10.2",
+    "tomlkit>=0.11.6",
+]
+
+[build-system]
+requires = [
+    "setuptools>=76",
 ]
+build-backend = "setuptools.build_meta"
+
+[tool.setuptools]
+license-files = []

File changed: setup.py
@@ -1,40 +1,9 @@
 import io
 import re
-
 from setuptools import setup
 
-
 def read(path):
-    with io.open(path, mode="r", encoding="utf-8") as fd:
+    with io.open(path, mode='r', encoding='utf-8') as fd:
         content = fd.read()
-    # Convert Markdown links to reStructuredText links
-    return re.sub(r"\[([^]]+)\]\(([^)]+)\)", r"`\1 <\2>`_", content)
-
-
-setup(
-    name="EbookLib",
-    version="0.18.1",
-    author="Aleksandar Erkalovic",
-    author_email="aerkalov@gmail.com",
-    packages=["ebooklib", "ebooklib.plugins"],
-    url="https://github.com/aerkalov/ebooklib",
-    license="GNU Affero General Public License",
-    description="Ebook library which can handle EPUB2/EPUB3 format",
-    long_description=read("README.md"),
-    long_description_content_type="text/markdown",
-    keywords=["ebook", "epub"],
-    classifiers=[
-        "Development Status :: 4 - Beta",
-        "Intended Audience :: Developers",
-        "Operating System :: OS Independent",
-        "Programming Language :: Python :: 3.6",
-        "Programming Language :: Python :: 3.7",
-        "Programming Language :: Python :: 3.8",
-        "Programming Language :: Python :: 3.9",
-        "Programming Language :: Python :: 3.10",
-        "Programming Language :: Python :: 3.11",
-        "Programming Language :: Python :: 3.12",
-        "Topic :: Software Development :: Libraries :: Python Modules",
-    ],
-    install_requires=["lxml", "six"],
-)
+    return re.sub('\\[([^]]+)\\]\\(([^)]+)\\)', '`\\1 <\\2>`_', content)
+setup(name='EbookLib', version='0.18.1', author='Aleksandar Erkalovic', author_email='aerkalov@gmail.com', packages=['ebooklib', 'ebooklib.plugins'], url='https://github.com/aerkalov/ebooklib', license='GNU Affero General Public License', description='Ebook library which can handle EPUB2/EPUB3 format', long_description=read('README.md'), long_description_content_type='text/markdown', keywords=['ebook', 'epub'], classifiers=['License :: OSI Approved :: GNU Affero General Public License v3', 'Development Status :: 4 - Beta', 'Intended Audience :: Developers', 'Operating System :: OS Independent', 'Programming Language :: Python :: 3.6', 'Programming Language :: Python :: 3.7', 'Programming Language :: Python :: 3.8', 'Programming Language :: Python :: 3.9', 'Programming Language :: Python :: 3.10', 'Programming Language :: Python :: 3.11', 'Programming Language :: Python :: 3.12', 'Topic :: Software Development :: Libraries :: Python Modules'], install_requires=['lxml', 'six'])
\ No newline at end of file

File changed: uv.lock

-------------------------

Commit Hash: 54a120d55ac5d6d0761ff5e80970d79b8bc4f407
Commit Message: replace setup.py with blank file
Diff: (5 files changed)
File added: .scripts/update_packaging.py
@@ -0,0 +1,516 @@
+# /// script
+# dependencies = [
+#     "tomlkit",
+# ]
+# ///
+
+import ast
+import json
+import re
+import sys
+from collections.abc import Callable, Generator
+from enum import Enum
+from pathlib import Path
+from typing import Any, TypeAlias
+
+import tomlkit
+from tomlkit.items import Array, Table
+
+
+MIN_PY3_SUPPORTED_VERSION = 9
+MAX_PY3_SUPPORTED_VERSION = 12
+
+FORK_MAINTAINER = {"name": "Ashlynn Antrobus", "email": "ashlynn@prosepal.io"}
+
+LEGACY_SETUP = "from setuptools import setup\n\n\nsetup()\n"
+
+Configuration: TypeAlias = str | list[str] | dict[str, Any]
+PyProject: TypeAlias = dict[str, Configuration]
+
+
+class Format(Enum):
+    SETUP = 1
+    PYPROJECT = 2
+
+
+def replace_setup(setup_path: Path, legacy_setup: str = LEGACY_SETUP) -> None:
+    """Replace the existing setup.py file"""
+    with setup_path.open("w", encoding="utf-8") as f:
+        f.write(legacy_setup)
+
+
+def parse_authors(authors_path: Path) -> dict[str, str]:
+    """Parse the authors file and return a dictionary of names and emails."""
+    authors = {}
+    lines = [line.strip() for line in authors_path.read_text().splitlines()]
+
+    for line in lines:
+        if line.startswith("Listed"):
+            continue
+        name, email = line.split(" <") if "<" in line else (line, "")
+        authors[name] = email.strip(">")
+
+    return authors
+
+
+def create_inline_array(input_dict: dict[str, str]) -> Array:
+    """Creates a tomlkit array on inline tables for authors/maintainers"""
+    array = tomlkit.array()
+    for name, email in input_dict.items():
+        inline_table = tomlkit.inline_table()
+        inline_table.update(
+            {"name": name, "email": email} if email else {"name": name}
+        )
+        array.append(inline_table)
+
+    return array
+
+
+def update_classifiers(classifiers: list[str]) -> Array:
+    """Creates a tomlkit array of project classifiers"""
+    array = tomlkit.array()
+    array.extend(classifiers)
+    return array
+
+
+def update_dependencies(
+    requirements: list[str], proj_dependencies: list[str]
+) -> Array:
+    """
+    Creates a tomlkit array of project dependencies from existing dependencies
+    and requirements
+    """
+    array = tomlkit.array()
+    dependencies: dict[str, str] = {
+        re.split(r"[<>=!~]", dependency)[0].strip(): dependency
+        for dependency in proj_dependencies
+    }
+
+    array.extend(dependencies[package] for package in requirements)
+    return array
+
+
+def update_maintainers(
+    sections: dict[str, str | list[str]],
+    auto_maintainer: dict = FORK_MAINTAINER,
+) -> Array:
+    """Creates a tomlkit inline array of project maintainers"""
+    maintainers = {
+        auto_maintainer["name"]: auto_maintainer["email"],
+        sections["maintainer"]: sections["maintainer_email"],
+    }
+    return create_inline_array(maintainers)
+
+
+def update_py_version(classifiers: list[str]) -> str:
+    """Build the `requires_python` string"""
+    requires_python = min(
+        (
+            classifier.strip("Programming Language :: Python :: ")
+            for classifier in classifiers
+            if "Programming Language" in classifier
+        ),
+        key=lambda version: int(version.split(".")[1]),
+    )
+
+    return f">={requires_python}"
+
+
+def update_urls(proj_urls: Table, home_url: str) -> Table:
+    """Create a urls table from new homepage url and other existing urls"""
+    urls = tomlkit.table()
+    urls.add("Homepage", home_url)
+    for page, url in proj_urls.value.body:
+        if page != "Homepage":
+            urls.add(page, url)
+    return urls
+
+
+def update_table_item(
+    item: str, project: Table, sections: dict, authors: dict
+) -> Table:
+    """Returns the updated value for a project table item."""
+    match item:
+        case "authors":
+            value = create_inline_array(authors)
+        case "classifiers":
+            value = update_classifiers(sections["classifiers"])
+        case "dependencies":
+            value = update_dependencies(
+                sections.get(
+                    "dependencies",
+                    sections["install_requires"],
+                    project["dependencies"],
+                )
+            )
+        case "maintainers":
+            value = update_maintainers(sections)
+        case "requires-python":
+            value = sections.get(
+                "requires_python", update_py_version(sections["classifiers"])
+            )
+        case "urls":
+            value = sections.get(
+                "urls", update_urls(project["urls"], sections["url"])
+            )
+        case _:
+            value = sections.get(item)
+    if item in {"classifiers", "dependencies", "authors", "maintainers"}:
+        value.multiline(True)
+    return value
+
+
+def sort_project_table(
+    doc: tomlkit.TOMLDocument,
+    sections: dict[str, str | list],
+    authors: dict[str, str],
+) -> tomlkit.TOMLDocument:
+    order = [
+        "name",
+        "version",
+        "description",
+        "readme",
+        "requires-python",
+        "license",
+        "keywords",
+        "classifiers",
+        "maintainers",
+        "authors",
+        "nl",  # A blank line
+        "dependencies",
+        "urls",
+    ]
+
+    table = tomlkit.table()
+
+    for item in order:
+        if item == "nl":
+            table.add(tomlkit.nl())
+            continue
+        value = (
+            update_table_item(item, doc["project"], sections, authors)
+            or doc["project"][item]
+        )
+        table.raw_append(item, value)
+
+    doc["project"] = table
+
+    return doc
+
+
+def update_pyproject(
+    toml_path: Path,
+    sections: dict[str, str | list[str]],
+    authors: dict[str, str],
+) -> None:
+    """Updates pyproject.toml with new values."""
+    with open(toml_path, "r", encoding="utf-8") as f:
+        doc = tomlkit.load(f)
+
+    updated_doc = sort_project_table(doc, sections, authors)
+    toml_text = re.sub("\n{3,}", "\n\n", tomlkit.dumps(updated_doc))
+
+    with toml_path.open("w", encoding="utf-8") as f:
+        f.write(toml_text)
+
+
+def build_supported_versions_list(
+    min_version: int = MIN_PY3_SUPPORTED_VERSION,
+    max_version: int = MAX_PY3_SUPPORTED_VERSION,
+) -> list[str]:
+    """Build a list of supported Python versions."""
+    assert min_version <= max_version
+    return [f"3.{version}" for version in range(min_version, max_version + 1)]
+
+
+def find_license_id(
+    license_name: str, license_data: dict
+) -> Generator[str, None, None]:
+    """Yield a SPDX license ID for the given license name."""
+    licenses = license_data.get("licenses", [])
+    normalized_name = license_name.lower().strip()
+
+    yield from (
+        license["licenseId"]
+        for license in licenses
+        if license["name"].lower().startswith(normalized_name)
+    )
+
+
+def convert_license(license: str, license_data: dict) -> str:
+    """
+    Convert a license name to a SPDX license ID.
+
+    Return the first SPDX license ID found for the given license name or raise a ValueError.
+
+    Args:
+        license (str): The name of the license.
+        license_data (dict): The SPDX license JSON data.
+
+    Returns:
+        str: The SPDX license ID.
+    """
+    try:
+        spdx_id = next(find_license_id(license, license_data))
+        return "{text = %s}" % spdx_id
+    except StopIteration as e:
+        raise ValueError(f"License ID not found for '{license}'") from e
+
+
+def convert_long_description(long_description: str) -> str:
+    """
+    Return the file name from the `long_description` function call in the
+    setup.py AST.
+    """
+    return long_description.lstrip("read(").rstrip(")").strip("'\"")
+
+
+def get_value(node: ast.AST) -> str | list[str]:
+    """Helper function to convert AST nodes to Python values"""
+    match node:
+        case ast.Constant(value=value):
+            return value
+        case ast.List(elts=elts):
+            return [get_value(elt) for elt in elts]
+        case ast.Call(args=args):
+            return get_value(args[0])
+    raise ValueError(f"Unhandled AST node type: {type(node)}")
+
+
+def is_setup_call(node: ast.AST) -> bool:
+    """
+    Check if the node is a call to the `setup` function.
+    """
+    return (
+        hasattr(node, "value")
+        and hasattr(node.value, "func")
+        and hasattr(node.value.func, "id")
+        and node.value.func.id == "setup"
+    )
+
+
+def extract_setup_keywords(ast_tree: ast.AST) -> dict[str, str | list[str]]:
+    """
+    Extract keyword arguments and their values from the setup() call in an AST
+    """
+    for node in ast.walk(ast_tree):
+        if is_setup_call(node):
+            return {
+                keyword.arg: get_value(keyword.value)
+                for keyword in node.value.keywords
+            }
+    raise ValueError("setup() call not found")
+
+
+def parse_ast(setup_path: Path) -> dict[str, str | list[str]]:
+    """Parse the setup.py file and return the project configuration."""
+    tree = ast.parse(setup_path.read_text(encoding="utf-8"))
+
+    return extract_setup_keywords(tree)
+
+
+def parse_pyproject(pyproject_path: Path) -> dict[str, str | list[str]]:
+    """Parse the pyproject.toml file and return the project configuration."""
+    with open(pyproject_path, "r", encoding="utf-8") as f:
+        doc = tomlkit.load(f)
+    return doc["project"]
+
+
+class ProjectParser:
+    """Parser for Python project configuration files."""
+
+    MUTUAL_SECTIONS = [
+        "version",
+        "license",
+        "description",
+        "keywords",
+        "classifiers",
+    ]
+
+    FORMAT_SECTIONS = {
+        Format.SETUP_PY: [
+            "author",
+            "author_email",
+            "long_description",
+            "url",
+            "install_requires",
+        ],
+        Format.PYPROJECT_TOML: [
+            "authors",
+            "maintainers",
+            "readme",
+            "dependencies",
+            "requires_python",
+            "urls",
+        ],
+    }
+
+    def __init__(self, license_data: dict[str, Any]):
+        """
+        Initialize the project configuration parser.
+
+        Args:
+            license_data: dictionary of license information for conversion
+        """
+        self.license_data = license_data
+        self._transformers: dict[
+            str, Callable[[Configuration], Configuration]
+        ] = {
+            "description": self._transform_description,
+            "keywords": self._transform_keywords,
+            "classifiers": self._transform_classifiers,
+        }
+
+    @staticmethod
+    def detect_format(
+        setup_path: Path, legacy_setup_content: str = ""
+    ) -> Format:
+        """
+        Detect the configuration format based on setup.py content.
+
+        Args:
+            setup_path: Path to setup.py file
+            legacy_setup_content: Content of legacy setup.py that indicates pyproject usage
+
+        Returns:
+            Detected configuration format
+        """
+        content = setup_path.read_text(encoding="utf-8")
+        return (
+            Format.PYPROJECT
+            if content.strip() == legacy_setup_content
+            else Format.SETUP
+        )
+
+    def parse(
+        self, config_format: Format, setup_path: Path, pyproject_path: Path
+    ) -> PyProject:
+        """
+        Parse the project configuration based on the detected format.
+
+        Args:
+            config_format: The configuration format to use
+            setup_path: Path to setup.py file
+            pyproject_path: Path to pyproject.toml file
+
+        Returns:
+            Parsed and normalized project configuration
+        """
+        raw_config = (
+            parse_ast(setup_path)
+            if config_format == Format.SETUP_PY
+            else parse_pyproject(pyproject_path)
+        )
+
+        transformed_config = self._apply_transformations(raw_config)
+        return self._normalize_config(transformed_config, config_format)
+
+    def _apply_transformations(self, config: PyProject) -> PyProject:
+        """Apply transformations to configuration values."""
+        result = config.copy()
+
+        for key, transformer in self._transformers.items():
+            if key in result:
+                result[key] = transformer(result[key])
+
+        return result
+
+    def _normalize_config(
+        self, config: PyProject, format: Format
+    ) -> PyProject:
+        """
+        Normalize configuration to a consistent format regardless of source.
+
+        Args:
+            config: The configuration to normalize
+            source_format: The format the configuration came from
+
+        Returns:
+            Normalized configuration
+        """
+        sections: PyProject = {
+            keyword: config[keyword] for keyword in config
+        } | {
+            keyword: config[keyword]
+            for keyword in self.FORMAT_SECTIONS[format]
+        }
+
+        if format == Format.SETUP:
+            sections |= {
+                "readme": sections.pop("long_description"),
+                "license": convert_license(
+                    sections["license"], self.license_data
+                ),
+                "maintainer": sections.pop("author"),
+                "maintainer_email": sections.pop("author_email"),
+            }
+
+        return sections
+
+    def _transform_description(self, description: str) -> str:
+        """Transform the project description."""
+        return description.replace("and kindle ", "").replace(
+            "and Kindle ", ""
+        )
+
+    def _transform_keywords(self, _: Any) -> list[str]:
+        """Transform keywords."""
+        return ["ebook", "epub"]
+
+    def _transform_classifiers(self, classifiers: list[str]) -> list[str]:
+        """Transform Python classifiers."""
+        supported_versions = build_supported_versions_list()
+        new_classifiers = []
+        python_section_added = False
+
+        for classifier in classifiers:
+            if "License" in classifier:
+                continue
+            if "Programming Language :: Python :: " not in classifier:
+                new_classifiers.append(classifier)
+                continue
+            if python_section_added:
+                continue
+            python_section_added = True
+            new_classifiers.extend(
+                f"Programming Language :: Python :: {version}"
+                for version in supported_versions
+            )
+
+        return new_classifiers
+
+
+def main(
+    author_path: Path,
+    setup_path: Path,
+    pyproject_path: Path,
+    license_path: Path,
+) -> None:
+    """
+    Main function.
+
+    Args:
+        author_file (Path): Path to the authors file.
+        setup_file (Path): Path to the setup.py file.
+        pyproject_file (Path): Path to the pyproject.toml file.
+        license_file (Path): Path to the license file.
+    """
+    authors = parse_authors(author_path)
+
+    with license_path.open("r", encoding="utf-8") as f:
+        license_data = json.load(f)
+
+    parser = ProjectParser(license_data)
+    update_file = parser.detect_format(setup_path)
+    sections = parser.parse(update_file, setup_path, pyproject_path)
+    update_pyproject(pyproject_path, sections, authors)
+    replace_setup(setup_path)
+
+
+if __name__ == "__main__":
+    _, setup_file, author_file, pyproject_file, license_file = sys.argv
+    setup_path = Path(setup_file)
+    author_path = Path(author_file)
+    pyproject_path = Path(pyproject_file)
+    license_path = Path(license_file)
+    main(author_path, setup_path, pyproject_path, license_path)

File changed: .scripts/update_readme.py
@@ -3,9 +3,26 @@ import sys
 
 
 def update_readme(readme_file: str) -> None:
+    """
+    Updates README.md with new values and a preamble.
+
+    This function checks if updates are necessary, and if so, splits the
+    readme file into sections split at code-fenced blocks. At non-code fenced
+    sections, it increments the heading levels by one and removes the `and
+    kindle ` prefix.
+
+    It then joins the sections back together and writes the updated content
+    back to the file along with a preamble.
+
+    Args:
+        readme_file (str): The path to the README.md file.
+    """
     with open(readme_file, "r") as f:
         content: str = f.read()
 
+    if content.startswith("# EbookLib-autoupdate"):
+        return
+
     sections: list[str] = re.split(r"(```.*?```)", content, flags=re.DOTALL)
     updated_sections: list[str] = []
 

.scripts/update_setup.py deleted
File changed: pyproject.toml
@@ -4,10 +4,9 @@ version = "0.18.1"
 description = "Ebook library which can handle EPUB2/EPUB3 format"
 readme = "README.md"
 requires-python = ">=3.6"
-license = "AGPL-3.0"
+license = { text = "AGPL-3.0" }
 keywords = ["ebook", "epub"]
 classifiers = [
-    "License :: OSI Approved :: GNU Affero General Public License v3",
     "Development Status :: 4 - Beta",
     "Intended Audience :: Developers",
     "Operating System :: OS Independent",
@@ -82,3 +81,7 @@ build-backend = "setuptools.build_meta"
 
 [tool.setuptools]
 license-files = []
+
+[tool.setuptools.packages.find]
+include = ["ebooklib*"]
+exclude = ["samples*", ".scripts*", "tests*"]

File changed: setup.py
@@ -1,9 +1,3 @@
-import io
-import re
 from setuptools import setup
 
-def read(path):
-    with io.open(path, mode='r', encoding='utf-8') as fd:
-        content = fd.read()
-    return re.sub('\\[([^]]+)\\]\\(([^)]+)\\)', '`\\1 <\\2>`_', content)
-setup(name='EbookLib', version='0.18.1', author='Aleksandar Erkalovic', author_email='aerkalov@gmail.com', packages=['ebooklib', 'ebooklib.plugins'], url='https://github.com/aerkalov/ebooklib', license='GNU Affero General Public License', description='Ebook library which can handle EPUB2/EPUB3 format', long_description=read('README.md'), long_description_content_type='text/markdown', keywords=['ebook', 'epub'], classifiers=['License :: OSI Approved :: GNU Affero General Public License v3', 'Development Status :: 4 - Beta', 'Intended Audience :: Developers', 'Operating System :: OS Independent', 'Programming Language :: Python :: 3.6', 'Programming Language :: Python :: 3.7', 'Programming Language :: Python :: 3.8', 'Programming Language :: Python :: 3.9', 'Programming Language :: Python :: 3.10', 'Programming Language :: Python :: 3.11', 'Programming Language :: Python :: 3.12', 'Topic :: Software Development :: Libraries :: Python Modules'], install_requires=['lxml', 'six'])
\ No newline at end of file
+setup()
\ No newline at end of file

-------------------------

Commit Hash: 52eaeb0129efc826c6e29b01456359b2118585b6
Commit Message: split logic into own script
Diff: (5 files changed)
File changed: .github/workflows/auto-update.yml
@@ -11,10 +11,6 @@ permissions:
 
 env:
   VERSION_FILE: VERSION.txt
-  SETUP_FILE: setup.py
-  AUTHORS_FILE: AUTHORS.txt
-  PYPROJECT_FILE: pyproject.toml
-  README_FILE: README.md
 
 jobs:
   update:
@@ -43,92 +39,25 @@ jobs:
         id: upstream_changes
         run: |
           VERSION_TIMESTAMP=$(git log -1 --format=%at -- ${{ env.VERSION_FILE }})
-          UPSTREAM_SETUP_TIMESTAMP=$(git log upstream/master -1 --format=%at -- ${{ env.SETUP_FILE }})
-          UPSTREAM_README_TIMESTAMP=$(git log upstream/master -1 --format=%at -- ${{ env.README_FILE }})
           if [[ $(git log upstream/master -1 --format=%at) -gt $VERSION_TIMESTAMP ]]; then
             echo "updated_version=true" >> $GITHUB_OUTPUT
           else
             echo "updated_version=false" >> $GITHUB_OUTPUT
           fi
-          if [[ $UPSTREAM_SETUP_TIMESTAMP -gt $VERSION_TIMESTAMP ]]; then
-            echo "update_setup=true" >> $GITHUB_OUTPUT
-          else
-            echo "update_setup=false" >> $GITHUB_OUTPUT
-          fi
-          if [[ $UPSTREAM_README_TIMESTAMP -gt $VERSION_TIMESTAMP ]]; then
-            echo "update_readme=true" >> $GITHUB_OUTPUT
-          else
-            echo "update_readme=false" >> $GITHUB_OUTPUT
-          fi
 
       - name: Merge upstream changes
         if: steps.upstream_changes.outputs.updated_version == 'true'
         run: |
           {
             echo "${{ env.VERSION_FILE }} merge=theirs"
-            if [[ "${{ steps.upstream_changes.outputs.update_setup }}" == "true" ]]; then
-              echo "${{ env.SETUP_FILE }} merge=theirs"
-            else
-              echo "${{ env.SETUP_FILE }} merge=ours"
-            fi
           } > .gitattributes
           git merge upstream/master --no-edit
 
-      - name: Increment version
-        id: version
+      - name: Update files
         if: steps.upstream_changes.outputs.updated_version == 'true'
-        run: |
-          UPSTREAM_VERSION=$(grep -Eo '[0-9]+\.[0-9]+' "${{ env.VERSION_FILE }}")
-          IFS='.' read -r UPSTREAM_MAJOR UPSTREAM_MINOR <<< "$UPSTREAM_VERSION"
-          CURRENT_VERSION="${{ steps.fork_state.outputs.current_version }}"
-          IFS='.' read -r CURRENT_MAJOR CURRENT_MINOR PATCH <<< "$CURRENT_VERSION"
-          if [[ $UPSTREAM_MAJOR == $CURRENT_MAJOR && $UPSTREAM_MINOR == $CURRENT_MINOR ]]; then
-            PATCH=$(($PATCH + 1))
-            NEW_VERSION="$CURRENT_MAJOR.$CURRENT_MINOR.$PATCH"
-          else
-            NEW_VERSION="$UPSTREAM_MAJOR.$UPSTREAM_MINOR.0"
-          fi
-          sed -i "0,/$UPSTREAM_VERSION/s//$NEW_VERSION/" ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }}
-          sed -i "0,/$CURRENT_VERSION/s//$NEW_VERSION" ${{ env.PYPROJECT_FILE }}
-          git add ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }} ${{ env.PYPROJECT_FILE }}
-          git commit -m "Auto-increment version to $NEW_VERSION"
-
-      - name: Install uv
-        if: steps.upstream_changes.outputs.updated_version == 'true'
-        uses: astral-sh/setup-uv@v5
+        uses: ./.github/workflows/update-files.yml
         with:
-          enable-cache: true
-
-      - name: "Set up Python"
-        if: steps.upstream_changes.outputs.updated_version == 'true'
-        uses: actions/setup-python@v5
-        with:
-          python-version: "3.13"
-
-      - name: Update supported Python versions in setup.py
-        if: steps.upstream_changes.outputs.update_setup == 'true'
-        run: |
-          uv run .scripts/update_setup.py "${{ env.SETUP_FILE }}" "${{ env.AUTHORS_FILE }}" "${{ env.PYPROJECT_FILE }}"
-          uvx ruff format
-          git add "${{ env.SETUP_FILE }}"" "${{ env.PYPROJECT_FILE }}"
-          git commit -m "Update supported Python versions"
-
-      - name: Update README
-        if: steps.upstream_changes.outputs.update_readme == 'true'
-        run: |
-          python .scripts/update_readme.py "${{ env.README_FILE }}"
-          git add "${{ env.README_FILE }}"
-          git commit -m "Update README"
-
-      - name: Push changes to fork
-        if: steps.upstream_changes.outputs.updated_version == 'true'
-        run: git push origin master
-
-      - name: Build and publish
-        if: steps.upstream_changes.outputs.updated_version == 'true'
-        run: |
-          uv build
-          uv publish
+          updated_version: ${{ steps.upstream_changes.outputs.updated_version }}
 
       - name: Sync new branches
         run: |

File changed: .github/workflows/local-sync.yml
@@ -10,69 +10,8 @@ permissions:
   contents: write
   id-token: write
 
-env:
-  VERSION_FILE: VERSION.txt
-  SETUP_FILE: setup.py
-  AUTHORS_FILE: AUTHORS.txt
-  PYPROJECT_FILE: pyproject.toml
-  README_FILE: README.md
-
 jobs:
   process:
-    runs-on: ubuntu-latest
-    steps:
-      - name: Checkout
-        uses: actions/checkout@v4
-
-      - name: Set up Git user
-        run: |
-          git config --global user.name "github-actions[bot]"
-          git config --global user.email "github-actions[bot]@users.noreply.github.com"
-
-      - name: Read current version
-        id: fork_state
-        run: |
-          CURRENT_VERSION=$(grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' "${{ env.VERSION_FILE }}")
-          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
-
-      - name: Increment version
-        id: version
-        run: |
-          IFS='.' read -r MAJOR MINOR PATCH <<< "${{ steps.fork_state.outputs.current_version }}"
-          PATCH=$(($PATCH + 1))
-          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
-          sed -i "0,/${{ steps.fork_state.outputs.current_version }}/s//${NEW_VERSION}/" ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }}
-          sed -i "0,/${{ steps.fork_state.outputs.current_version }}/s//${NEW_VERSION}/" ${{ env.PYPROJECT_FILE }}
-          git add ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }} ${{ env.PYPROJECT_FILE }}
-          git commit -m "Auto-increment version to $NEW_VERSION"
-
-      - name: Install uv
-        uses: astral-sh/setup-uv@v5
-        with:
-          enable-cache: true
-
-      - name: "Set up Python"
-        uses: actions/setup-python@v5
-        with:
-          python-version: "3.13"
-
-      - name: Update supported Python versions in setup.py
-        run: |
-          uv run .scripts/update_setup.py "${{ env.SETUP_FILE }}" "${{ env.AUTHORS_FILE }}" "${{ env.PYPROJECT_FILE }}"
-          uvx ruff format
-          git add "${{ env.SETUP_FILE }}" "${{ env.PYPROJECT_FILE }}"
-          git commit -m "Update supported Python versions"
-
-      - name: Update README
-        run: |
-          uv run .scripts/update_readme.py "${{ env.README_FILE }}"
-          git add "${{ env.README_FILE }}"
-          git commit -m "Update README"
-
-      - name: Push changes
-        run: git push origin master
-
-      - name: Build and publish
-        run: |
-          uv build
-          uv publish
+    uses: ./.github/workflows/update-files.yml
+    with:
+      updated_version: true
\ No newline at end of file

File added: .github/workflows/update-files.yml
@@ -0,0 +1,102 @@
+name: Update Files
+
+on:
+  workflow_call:
+    inputs:
+      updated_version:
+        required: true
+        type: boolean
+
+
+permissions:
+  contents: write
+  id-token: write
+
+env:
+  VERSION_FILE: VERSION.txt
+  SETUP_FILE: setup.py
+  AUTHORS_FILE: AUTHORS.txt
+  PYPROJECT_FILE: pyproject.toml
+  README_FILE: README.md
+
+jobs:
+  process:
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+
+      - name: Set up Git user
+        run: |
+          git config --global user.name "github-actions[bot]"
+          git config --global user.email "github-actions[bot]@users.noreply.github.com"
+
+      - name: Read current version
+        id: fork_state
+        run: |
+          CURRENT_VERSION=$(grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' "${{ env.VERSION_FILE }}")
+          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
+
+      - name: Increment version
+        id: version
+        run: |
+          IFS='.' read -r MAJOR MINOR PATCH <<< "${{ steps.fork_state.outputs.current_version }}"
+          PATCH=$(($PATCH + 1))
+          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
+          sed -i "0,/${{ steps.fork_state.outputs.current_version }}/s//${NEW_VERSION}/" ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }}
+          sed -i "0,/${{ steps.fork_state.outputs.current_version }}/s//${NEW_VERSION}/" ${{ env.PYPROJECT_FILE }}
+          git add ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }} ${{ env.PYPROJECT_FILE }}
+          git commit -m "Auto-increment version to $NEW_VERSION"
+
+      - name: Install uv
+        uses: astral-sh/setup-uv@v5
+        with:
+          enable-cache: true
+
+      - name: "Set up Python"
+        uses: actions/setup-python@v5
+        with:
+          python-version: "3.13"
+
+      - name: Download license artifact
+        id: license-artifact
+        uses: actions/download-artifact@v3
+        continue-on-error: true
+        with:
+          name: license-data
+          path: ./scripts/license-data
+
+      - name: Download license data
+        if: steps.license-artifact.outcome == 'failure'
+        run: uv run .scripts/download_license_data.py
+
+      - name: Upload license artifact
+        if: steps.license-artifact.outcome == 'failure'
+        uses: actions/upload-artifact@v3
+        with:
+          name: license-data
+          path: ./scripts/license-data
+
+      - name: Add license data to env
+        run: echo "LICENSE_DATA=$(pwd)/scripts/license-data" >> $GITHUB_ENV
+
+      - name: Update packaging
+        run: |
+          uv run .scripts/update_packaging.py "${{ env.SETUP_FILE }}" "${{ env.AUTHORS_FILE }}" "${{ env.PYPROJECT_FILE }}" "${{ env.LICENSE_DATA }}"
+          uvx ruff format
+          git add "${{ env.SETUP_FILE }}" "${{ env.PYPROJECT_FILE }}"
+          git commit -m "Update supported Python versions"
+
+      - name: Update README
+        run: |
+          uv run .scripts/update_readme.py "${{ env.README_FILE }}"
+          git add "${{ env.README_FILE }}"
+          git commit -m "Update README"
+
+      - name: Push changes
+        run: git push origin master
+
+      - name: Build and publish
+        run: |
+          uv build
+          uv publish

File added: .scripts/download_license_data.py
@@ -0,0 +1,41 @@
+# /// script
+# dependencies = [
+#     "requests",
+# ]
+# ///
+import time
+import json
+
+import requests
+
+URL = "https://raw.githubusercontent.com/spdx/license-list-data/refs/heads/main/json/licenses.json"
+
+
+def download_file(url: str) -> dict:
+    """Download file at url"""
+    response = requests.get(url, timeout=10)
+    response.raise_for_status()  # Raise an error for HTTP issues
+    return response.json()
+
+
+def fetch_data(url: str, retry: int = 0) -> dict:
+    """Fetch the license JSON from the given URL with retries."""
+    try:
+        return download_file(url)
+    except requests.exceptions.RequestException as e:
+        if retry > 3:
+            exit(1, f"Failed to fetch data from {url}: {e}")
+        retry += 1
+        backoff = 2**retry
+        time.sleep(backoff)
+        return fetch_data(url, retry)
+
+
+def main() -> None:
+    data = fetch_data(URL)
+    with open("licenses.json", "w") as f:
+        json.dump(data, f)
+
+
+if __name__ == "__main__":
+    main()

File changed: pyproject.toml
@@ -68,10 +68,6 @@ dependencies = [
 Homepage = "https://github.com/aerkalov/ebooklib"
 "Documentation" = "https://ebooklib.readthedocs.io"
 
-[dependency-groups]
-workflow = [
-    "tomlkit>=0.11.6",
-]
 
 [build-system]
 requires = [

-------------------------

Commit Hash: 0217ee120c6b1d8ec706e637f616a153dbb3f352
Commit Message: Rename job
Diff: (4 files changed)
File changed: .github/workflows/local-sync.yml
@@ -11,7 +11,7 @@ permissions:
   id-token: write
 
 jobs:
-  process:
+  update-files:
     uses: ./.github/workflows/update-files.yml
     with:
       updated_version: true
\ No newline at end of file

File changed: .github/workflows/update-files.yml
@@ -72,7 +72,7 @@ jobs:
 
       - name: Upload license artifact
         if: steps.license-artifact.outcome == 'failure'
-        uses: actions/upload-artifact@v3
+        uses: actions/upload-artifact@v4
         with:
           name: license-data
           path: ./scripts/license-data

File changed: .scripts/update_packaging.py
@@ -10,6 +10,7 @@ import re
 import sys
 from collections.abc import Callable, Generator
 from enum import Enum
+from functools import cache
 from pathlib import Path
 from typing import Any, TypeAlias
 
@@ -33,6 +34,16 @@ class Format(Enum):
     PYPROJECT = 2
 
 
+@cache
+def build_supported_versions_list(
+    min_version: int = MIN_PY3_SUPPORTED_VERSION,
+    max_version: int = MAX_PY3_SUPPORTED_VERSION,
+) -> list[str]:
+    """Build a list of supported Python versions."""
+    assert min_version <= max_version
+    return [f"3.{version}" for version in range(min_version, max_version + 1)]
+
+
 def replace_setup(setup_path: Path, legacy_setup: str = LEGACY_SETUP) -> None:
     """Replace the existing setup.py file"""
     with setup_path.open("w", encoding="utf-8") as f:
@@ -102,16 +113,10 @@ def update_maintainers(
     return create_inline_array(maintainers)
 
 
-def update_py_version(classifiers: list[str]) -> str:
+def min_supported_py_version() -> str:
     """Build the `requires_python` string"""
-    requires_python = min(
-        (
-            classifier.strip("Programming Language :: Python :: ")
-            for classifier in classifiers
-            if "Programming Language" in classifier
-        ),
-        key=lambda version: int(version.split(".")[1]),
-    )
+    versions = build_supported_versions_list()
+    requires_python = min(versions)
 
     return f">={requires_python}"
 
@@ -136,9 +141,10 @@ def update_table_item(
         case "classifiers":
             value = update_classifiers(sections["classifiers"])
         case "dependencies":
-            value = update_dependencies(
-                sections.get(
-                    "dependencies",
+            value = (
+                update_dependencies("", sections.get("dependencies"))
+                if sections.get("dependencies")
+                else update_dependencies(
                     sections["install_requires"],
                     project["dependencies"],
                 )
@@ -146,9 +152,7 @@ def update_table_item(
         case "maintainers":
             value = update_maintainers(sections)
         case "requires-python":
-            value = sections.get(
-                "requires_python", update_py_version(sections["classifiers"])
-            )
+            value = sections.get("requires_python", min_supported_py_version())
         case "urls":
             value = sections.get(
                 "urls", update_urls(project["urls"], sections["url"])
@@ -214,15 +218,6 @@ def update_pyproject(
         f.write(toml_text)
 
 
-def build_supported_versions_list(
-    min_version: int = MIN_PY3_SUPPORTED_VERSION,
-    max_version: int = MAX_PY3_SUPPORTED_VERSION,
-) -> list[str]:
-    """Build a list of supported Python versions."""
-    assert min_version <= max_version
-    return [f"3.{version}" for version in range(min_version, max_version + 1)]
-
-
 def find_license_id(
     license_name: str, license_data: dict
 ) -> Generator[str, None, None]:
@@ -328,14 +323,14 @@ class ProjectParser:
     ]
 
     FORMAT_SECTIONS = {
-        Format.SETUP_PY: [
+        Format.SETUP: [
             "author",
             "author_email",
             "long_description",
             "url",
             "install_requires",
         ],
-        Format.PYPROJECT_TOML: [
+        Format.PYPROJECT: [
             "authors",
             "maintainers",
             "readme",
@@ -363,7 +358,7 @@ class ProjectParser:
 
     @staticmethod
     def detect_format(
-        setup_path: Path, legacy_setup_content: str = ""
+        setup_path: Path, legacy_setup_content: str = LEGACY_SETUP
     ) -> Format:
         """
         Detect the configuration format based on setup.py content.
@@ -398,7 +393,7 @@ class ProjectParser:
         """
         raw_config = (
             parse_ast(setup_path)
-            if config_format == Format.SETUP_PY
+            if config_format == Format.SETUP
             else parse_pyproject(pyproject_path)
         )
 

File changed: uv.lock

-------------------------

Commit Hash: 7938392a4d45eb0548eab9118bdfd126269a404e
Commit Message: Use Path for file operation
Diff: (4 files changed)
File changed: .github/workflows/update-files.yml
@@ -64,7 +64,7 @@ jobs:
         continue-on-error: true
         with:
           name: license-data
-          path: ./scripts/license-data
+          path: ./.scripts/license-data.json
 
       - name: Download license data
         if: steps.license-artifact.outcome == 'failure'
@@ -75,10 +75,10 @@ jobs:
         uses: actions/upload-artifact@v4
         with:
           name: license-data
-          path: ./scripts/license-data
+          path: ./.scripts/license-data.json
 
       - name: Add license data to env
-        run: echo "LICENSE_DATA=$(pwd)/scripts/license-data" >> $GITHUB_ENV
+        run: echo "LICENSE_DATA=$(pwd)/.scripts/license-data.json" >> $GITHUB_ENV
 
       - name: Update packaging
         run: |

File changed: .scripts/download_license_data.py
@@ -5,6 +5,7 @@
 # ///
 import time
 import json
+from pathlib import Path
 
 import requests
 
@@ -32,9 +33,15 @@ def fetch_data(url: str, retry: int = 0) -> dict:
 
 
 def main() -> None:
+    file = Path(__file__).parent / "license-data.json"
     data = fetch_data(URL)
-    with open("licenses.json", "w") as f:
+    print(f"Downloaded {len(data)} licenses")
+    with file.open("w", encoding="utf-8") as f:
         json.dump(data, f)
+    if file.exists():
+        print(f"License data downloaded to {file.as_posix()}")
+    else:
+        exit(1, f"Failed to write license data to {file}")
 
 
 if __name__ == "__main__":

File changed: .scripts/update_packaging.py
@@ -30,8 +30,8 @@ PyProject: TypeAlias = dict[str, Configuration]
 
 
 class Format(Enum):
-    SETUP = 1
-    PYPROJECT = 2
+    SETUP = "setup.py"
+    PYPROJECT = "pyproject.toml"
 
 
 @cache
@@ -152,7 +152,7 @@ def update_table_item(
         case "maintainers":
             value = update_maintainers(sections)
         case "requires-python":
-            value = sections.get("requires_python", min_supported_py_version())
+            value = sections.get("requires-python", min_supported_py_version())
         case "urls":
             value = sections.get(
                 "urls", update_urls(project["urls"], sections["url"])
@@ -315,6 +315,7 @@ class ProjectParser:
     """Parser for Python project configuration files."""
 
     MUTUAL_SECTIONS = [
+        "name",
         "version",
         "license",
         "description",
@@ -335,7 +336,7 @@ class ProjectParser:
             "maintainers",
             "readme",
             "dependencies",
-            "requires_python",
+            "requires-python",
             "urls",
         ],
     }
@@ -373,7 +374,7 @@ class ProjectParser:
         content = setup_path.read_text(encoding="utf-8")
         return (
             Format.PYPROJECT
-            if content.strip() == legacy_setup_content
+            if content.strip() == legacy_setup_content.strip()
             else Format.SETUP
         )
 
@@ -497,6 +498,8 @@ def main(
 
     parser = ProjectParser(license_data)
     update_file = parser.detect_format(setup_path)
+    print(f"Detected format: {update_file.value}")
+
     sections = parser.parse(update_file, setup_path, pyproject_path)
     update_pyproject(pyproject_path, sections, authors)
     replace_setup(setup_path)

File changed: setup.py
@@ -1,3 +1,4 @@
 from setuptools import setup
 
-setup()
\ No newline at end of file
+
+setup()

-------------------------

Commit Hash: 30a9051aa4d2da9b9e51ec4bcfcd65d1f600cea6
Commit Message: Switch from artifacts to cache
Diff: (2 files changed)
File changed: .github/workflows/update-files.yml
@@ -58,24 +58,23 @@ jobs:
         with:
           python-version: "3.13"
 
-      - name: Download license artifact
-        id: license-artifact
-        uses: actions/download-artifact@v3
-        continue-on-error: true
+      - name: Restore license data from cache
+        id: license-cache
+        uses: actions/cache@v4
         with:
-          name: license-data
           path: ./.scripts/license-data.json
+          key: license-data
 
       - name: Download license data
-        if: steps.license-artifact.outcome == 'failure'
+        if: steps.license-cache.outputs.cache-hit != 'true'
         run: uv run .scripts/download_license_data.py
 
-      - name: Upload license artifact
-        if: steps.license-artifact.outcome == 'failure'
-        uses: actions/upload-artifact@v4
+      - name: Cache license data
+        if: steps.license-cache.outputs.cache-hit != 'true'
+        uses: actions/cache@v4
         with:
-          name: license-data
           path: ./.scripts/license-data.json
+          key: license-data
 
       - name: Add license data to env
         run: echo "LICENSE_DATA=$(pwd)/.scripts/license-data.json" >> $GITHUB_ENV

File changed: .scripts/update_packaging.py
@@ -68,7 +68,7 @@ def create_inline_array(input_dict: dict[str, str]) -> Array:
     """Creates a tomlkit array on inline tables for authors/maintainers"""
     array = tomlkit.array()
     for name, email in input_dict.items():
-        inline_table = tomlkit.inline_table()
+        inline_table: tomlkit.items.InlineTable = tomlkit.inline_table()
         inline_table.update(
             {"name": name, "email": email} if email else {"name": name}
         )
@@ -102,13 +102,20 @@ def update_dependencies(
 
 
 def update_maintainers(
-    sections: dict[str, str | list[str]],
-    auto_maintainer: dict = FORK_MAINTAINER,
+    section_maintainers: dict[str, str],
+    project_maintainers: Array,
+    fork_maintainer: dict[str, str] = FORK_MAINTAINER,
 ) -> Array:
     """Creates a tomlkit inline array of project maintainers"""
+    if section_maintainers == project_maintainers:
+        if fork_maintainer not in project_maintainers:
+            maintainer = create_inline_array(fork_maintainer)
+            project_maintainers.extend(maintainer)
+        return project_maintainers
+
     maintainers = {
-        auto_maintainer["name"]: auto_maintainer["email"],
-        sections["maintainer"]: sections["maintainer_email"],
+        fork_maintainer["name"]: fork_maintainer["email"],
+        section_maintainers["name"]: section_maintainers["email"],
     }
     return create_inline_array(maintainers)
 
@@ -132,7 +139,7 @@ def update_urls(proj_urls: Table, home_url: str) -> Table:
 
 
 def update_table_item(
-    item: str, project: Table, sections: dict, authors: dict
+    item: str, project: Table, sections: PyProject, authors: dict[str, str]
 ) -> Table:
     """Returns the updated value for a project table item."""
     match item:
@@ -150,13 +157,16 @@ def update_table_item(
                 )
             )
         case "maintainers":
-            value = update_maintainers(sections)
+            value = update_maintainers(
+                sections["maintainers"], project["maintainers"]
+            )
         case "requires-python":
             value = sections.get("requires-python", min_supported_py_version())
         case "urls":
             value = sections.get(
                 "urls", update_urls(project["urls"], sections["url"])
             )
+            sections.pop("url")
         case _:
             value = sections.get(item)
     if item in {"classifiers", "dependencies", "authors", "maintainers"}:
@@ -166,7 +176,7 @@ def update_table_item(
 
 def sort_project_table(
     doc: tomlkit.TOMLDocument,
-    sections: dict[str, str | list],
+    sections: PyProject,
     authors: dict[str, str],
 ) -> tomlkit.TOMLDocument:
     order = [
@@ -204,12 +214,12 @@ def sort_project_table(
 
 def update_pyproject(
     toml_path: Path,
-    sections: dict[str, str | list[str]],
+    sections: PyProject,
     authors: dict[str, str],
 ) -> None:
     """Updates pyproject.toml with new values."""
     with open(toml_path, "r", encoding="utf-8") as f:
-        doc = tomlkit.load(f)
+        doc: Table = tomlkit.load(f)
 
     updated_doc = sort_project_table(doc, sections, authors)
     toml_text = re.sub("\n{3,}", "\n\n", tomlkit.dumps(updated_doc))
@@ -304,11 +314,11 @@ def parse_ast(setup_path: Path) -> dict[str, str | list[str]]:
     return extract_setup_keywords(tree)
 
 
-def parse_pyproject(pyproject_path: Path) -> dict[str, str | list[str]]:
+def parse_pyproject(pyproject_path: Path) -> PyProject:
     """Parse the pyproject.toml file and return the project configuration."""
     with open(pyproject_path, "r", encoding="utf-8") as f:
         doc = tomlkit.load(f)
-    return doc["project"]
+    return doc["project"].unwrap()
 
 
 class ProjectParser:
@@ -437,7 +447,9 @@ class ProjectParser:
                 "license": convert_license(
                     sections["license"], self.license_data
                 ),
-                "maintainer": sections.pop("author"),
+                "maintainers": create_inline_array({
+                    sections["author"]: sections.pop("author")
+                }),
                 "maintainer_email": sections.pop("author_email"),
             }
 

-------------------------

Commit Hash: 6889534df70b509136b77b4e61a3166a486ee393
Commit Message: Fix key checks
Diff: (1 files changed)
File changed: .scripts/update_packaging.py
@@ -18,7 +18,7 @@ import tomlkit
 from tomlkit.items import Array, Table
 
 
-MIN_PY3_SUPPORTED_VERSION = 9
+MIN_PY3_SUPPORTED_VERSION = 6
 MAX_PY3_SUPPORTED_VERSION = 12
 
 FORK_MAINTAINER = {"name": "Ashlynn Antrobus", "email": "ashlynn@prosepal.io"}
@@ -68,6 +68,8 @@ def create_inline_array(input_dict: dict[str, str]) -> Array:
     """Creates a tomlkit array on inline tables for authors/maintainers"""
     array = tomlkit.array()
     for name, email in input_dict.items():
+        if not name:
+            continue
         inline_table: tomlkit.items.InlineTable = tomlkit.inline_table()
         inline_table.update(
             {"name": name, "email": email} if email else {"name": name}
@@ -102,7 +104,7 @@ def update_dependencies(
 
 
 def update_maintainers(
-    section_maintainers: dict[str, str],
+    section_maintainers: list[dict[str, str]],
     project_maintainers: Array,
     fork_maintainer: dict[str, str] = FORK_MAINTAINER,
 ) -> Array:
@@ -113,9 +115,10 @@ def update_maintainers(
             project_maintainers.extend(maintainer)
         return project_maintainers
 
+    section_maintainer = section_maintainers[0]
     maintainers = {
         fork_maintainer["name"]: fork_maintainer["email"],
-        section_maintainers["name"]: section_maintainers["email"],
+        section_maintainer["name"]: section_maintainer["email"],
     }
     return create_inline_array(maintainers)
 
@@ -140,7 +143,7 @@ def update_urls(proj_urls: Table, home_url: str) -> Table:
 
 def update_table_item(
     item: str, project: Table, sections: PyProject, authors: dict[str, str]
-) -> Table:
+) -> Configuration:
     """Returns the updated value for a project table item."""
     match item:
         case "authors":
@@ -163,10 +166,15 @@ def update_table_item(
         case "requires-python":
             value = sections.get("requires-python", min_supported_py_version())
         case "urls":
-            value = sections.get(
-                "urls", update_urls(project["urls"], sections["url"])
+            value = (
+                sections.get(
+                    "urls",
+                )
+                if sections.get("urls")
+                else update_urls(project.get("urls"), sections["url"])
             )
-            sections.pop("url")
+            if sections.get("url"):
+                sections.pop("url")
         case _:
             value = sections.get(item)
     if item in {"classifiers", "dependencies", "authors", "maintainers"}:
@@ -257,7 +265,9 @@ def convert_license(license: str, license_data: dict) -> str:
     """
     try:
         spdx_id = next(find_license_id(license, license_data))
-        return "{text = %s}" % spdx_id
+        license_table: tomlkit.items.InlineTable = tomlkit.inline_table()
+        license_table.update({"text": spdx_id})
+        return license_table
     except StopIteration as e:
         raise ValueError(f"License ID not found for '{license}'") from e
 
@@ -448,9 +458,8 @@ class ProjectParser:
                     sections["license"], self.license_data
                 ),
                 "maintainers": create_inline_array({
-                    sections["author"]: sections.pop("author")
+                    sections.pop("author"): sections.pop("author_email")
                 }),
-                "maintainer_email": sections.pop("author_email"),
             }
 
         return sections

-------------------------

Commit Hash: 2393eda3363365d42e8a5763c5c2966c7a0305db
Commit Message: Delete untracked license data after use
Diff: (1 files changed)
File changed: .github/workflows/update-files.yml
@@ -46,7 +46,9 @@ jobs:
           sed -i "0,/${{ steps.fork_state.outputs.current_version }}/s//${NEW_VERSION}/" ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }}
           sed -i "0,/${{ steps.fork_state.outputs.current_version }}/s//${NEW_VERSION}/" ${{ env.PYPROJECT_FILE }}
           git add ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }} ${{ env.PYPROJECT_FILE }}
-          git commit -m "Auto-increment version to $NEW_VERSION"
+          if git status --porcelain | grep -q -E "${{ env.VERSION_FILE }}|${{ env.SETUP_FILE }}|${{ env.PYPROJECT_FILE }}"; then
+            git commit -m "Auto-increment version to $NEW_VERSION"
+          fi
 
       - name: Install uv
         uses: astral-sh/setup-uv@v5
@@ -84,16 +86,29 @@ jobs:
           uv run .scripts/update_packaging.py "${{ env.SETUP_FILE }}" "${{ env.AUTHORS_FILE }}" "${{ env.PYPROJECT_FILE }}" "${{ env.LICENSE_DATA }}"
           uvx ruff format
           git add "${{ env.SETUP_FILE }}" "${{ env.PYPROJECT_FILE }}"
-          git commit -m "Update supported Python versions"
+          if git status --porcelain | grep -q -E "${{ env.SETUP_FILE }}|${{ env.PYPROJECT_FILE }}"; then
+            git commit -m "Update supported Python versions"
+          fi
+      - name: Remove license data
+        run: rm ${{ env.LICENSE_DATA }}
 
       - name: Update README
         run: |
           uv run .scripts/update_readme.py "${{ env.README_FILE }}"
           git add "${{ env.README_FILE }}"
-          git commit -m "Update README"
+          if git status --porcelain | grep -q "README.md"; then
+            git commit -m "Update README"
+          fi
 
       - name: Push changes
-        run: git push origin master
+        run: |
+          git restore *
+          if git log origin/master..HEAD | grep -q .; then
+            git push origin master
+          else
+            echo "No changes to push"
+          fi
+
 
       - name: Build and publish
         run: |

-------------------------

Commit Hash: df1edf983715ca944a32cf568e1e5e22420b2157
Commit Message: Do not restore changes
Diff: (3 files changed)
File changed: .github/workflows/update-files.yml
@@ -102,7 +102,6 @@ jobs:
 
       - name: Push changes
         run: |
-          git restore *
           if git log origin/master..HEAD | grep -q .; then
             git push origin master
           else

File changed: VERSION.txt
@@ -1 +1 @@
-EbookLib 0.18.1
+EbookLib 0.18.2

File changed: pyproject.toml
@@ -1,6 +1,6 @@
 [project]
 name = "ebooklib-autoupdate"
-version = "0.18.1"
+version = "0.18.2"
 description = "Ebook library which can handle EPUB2/EPUB3 format"
 readme = "README.md"
 requires-python = ">=3.6"

-------------------------

Commit Hash: 1982e1839cd66065ca090ec26d16c066bc3b370a
Commit Message: Update supported Python versions
Diff: (1 files changed)
File changed: pyproject.toml
@@ -4,7 +4,6 @@ version = "0.18.2"
 description = "Ebook library which can handle EPUB2/EPUB3 format"
 readme = "README.md"
 requires-python = ">=3.6"
-license = { text = "AGPL-3.0" }
 keywords = ["ebook", "epub"]
 classifiers = [
     "Development Status :: 4 - Beta",
@@ -58,16 +57,17 @@ authors = [
     {name = "Bono Lv", email = "lvscar@gmail.com"},
     {name = "Tom Ritchford", email = "tom@swirly.com"},
 ]
-
 dependencies = [
     "lxml>=4.9.0",
     "six>=1.16.0",
 ]
 
+[project.license]
+text = "AGPL-3.0"
+
 [project.urls]
 Homepage = "https://github.com/aerkalov/ebooklib"
-"Documentation" = "https://ebooklib.readthedocs.io"
-
+Documentation = "https://ebooklib.readthedocs.io"
 
 [build-system]
 requires = [

-------------------------

Commit Hash: 119e6a46841605a90616414bce113463c7a8caa5
Commit Message: Merge branch 'master' of https://github.com/ProsePal/ebooklib-autoupdate
Diff: (2 files changed)
File changed: .github/workflows/update-files.yml
@@ -20,7 +20,7 @@ env:
   README_FILE: README.md
 
 jobs:
-  process:
+  update-files:
     runs-on: ubuntu-latest
     steps:
       - name: Checkout

File changed: .scripts/update_packaging.py
@@ -135,6 +135,12 @@ def update_urls(proj_urls: Table, home_url: str) -> Table:
     """Create a urls table from new homepage url and other existing urls"""
     urls = tomlkit.table()
     urls.add("Homepage", home_url)
+<<<<<<< HEAD
+=======
+    if not proj_urls or proj_urls.value is None:
+        return urls
+
+>>>>>>> 6dcceb7df8ab3a4504f8c70f7d5ba3d050ff1653
     for page, url in proj_urls.value.body:
         if page != "Homepage":
             urls.add(page, url)

-------------------------

Commit Hash: 8d82397f2ed493500d5948886bb26b75bbfd56a4
Commit Message: Clean up files
Diff: (7 files changed)
File changed: .github/workflows/auto-update.yml
@@ -3,7 +3,6 @@ name: Auto-Update
 on:
   schedule:
     - cron: '0 0 * * 0'  # Every Sunday at midnight UTC
-  workflow_dispatch:
 
 permissions:
   contents: write
@@ -18,23 +17,20 @@ jobs:
     steps:
       - name: Checkout
         uses: actions/checkout@v4
+        with:
+          fetch-depth: 2
 
       - name: Add upstream repo
         run: |
           git remote add upstream https://github.com/aerkalov/ebooklib || echo "Upstream already added"
           git fetch upstream
 
-      - name: Read fork version
+      - name: Read current version
         id: fork_state
         run: |
           CURRENT_VERSION=$(grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' "${{ env.VERSION_FILE }}")
           echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
 
-      - name: Add GitHub Action Bot
-        run: |
-          git config --global user.name "github-actions[bot]"
-          git config --global user.email "github-actions[bot]@users.noreply.github.com"
-
       - name: Check if upstream has changes
         id: upstream_changes
         run: |
@@ -45,6 +41,11 @@ jobs:
             echo "updated_version=false" >> $GITHUB_OUTPUT
           fi
 
+      - name: Add GitHub Action Bot
+        run: |
+          git config --global user.name "github-actions[bot]"
+          git config --global user.email "github-actions[bot]@users.noreply.github.com"
+          
       - name: Merge upstream changes
         if: steps.upstream_changes.outputs.updated_version == 'true'
         run: |
@@ -57,7 +58,18 @@ jobs:
         if: steps.upstream_changes.outputs.updated_version == 'true'
         uses: ./.github/workflows/update-files.yml
         with:
-          updated_version: ${{ steps.upstream_changes.outputs.updated_version }}
+          current_version: ${{ steps.fork_state.outputs.current_version }}
+          
+      - name: Rebase commit history
+        if: steps.upstream_changes.outputs.updated_version == 'true'
+        run: |
+          git fetch origin
+          MERGE_COMMIT=$(git log -2 --pretty=%H origin/master | tail -n 1)
+          UPDATE_FILES_COMMIT=$(git rev-parse HEAD)
+          git checkout "$MERGE_COMMIT"
+          git cherry-pick "$UPDATE_FILES_COMMIT"
+          git commit --amend --no-edit
+          git push origin master --force 
 
       - name: Sync new branches
         run: |

File changed: .github/workflows/local-sync.yml
@@ -10,8 +10,40 @@ permissions:
   contents: write
   id-token: write
 
+env:
+  VERSION_FILE: VERSION.txt
+
 jobs:
-  update-files:
-    uses: ./.github/workflows/update-files.yml
-    with:
-      updated_version: true
\ No newline at end of file
+  update:
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+        with:
+          fetch-depth: 2
+
+      - name: Read version number
+        id: version
+        run: |
+          CURRENT_VERSION=$(grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' "${{ env.VERSION_FILE }}")
+          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
+         
+      - name: Update files
+        uses: ./.github/workflows/update-files.yml
+        with:
+          current_version: ${{ steps.version.outputs.current_version }}
+
+      - name: Set up Git user
+        run: |
+          git config --global user.name "github-actions[bot]"
+          git config --global user.email "github-actions[bot]@users.noreply.github.com"
+        
+      - name: Rebase commit history
+        run: |
+          git fetch origin
+          PREVIOUS_COMMIT=$(git log -2 --pretty=%H origin/master | tail -n 1)
+          UPDATE_FILES_COMMIT=$(git rev-parse HEAD)
+          git checkout "$PREVIOUS_COMMIT"
+          git cherry-pick "$UPDATE_FILES_COMMIT"
+          git commit --amend --no-edit
+          git push origin master --force
\ No newline at end of file

File changed: .github/workflows/update-files.yml
@@ -3,10 +3,9 @@ name: Update Files
 on:
   workflow_call:
     inputs:
-      updated_version:
+      current_version:
         required: true
-        type: boolean
-
+        type: string    
 
 permissions:
   contents: write
@@ -18,6 +17,7 @@ env:
   AUTHORS_FILE: AUTHORS.txt
   PYPROJECT_FILE: pyproject.toml
   README_FILE: README.md
+  SPDX_DATA_URL: https://raw.githubusercontent.com/spdx/license-list-data/refs/heads/main/json/licenses.json
 
 jobs:
   update-files:
@@ -31,24 +31,16 @@ jobs:
           git config --global user.name "github-actions[bot]"
           git config --global user.email "github-actions[bot]@users.noreply.github.com"
 
-      - name: Read current version
-        id: fork_state
-        run: |
-          CURRENT_VERSION=$(grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' "${{ env.VERSION_FILE }}")
-          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
-
       - name: Increment version
         id: version
         run: |
-          IFS='.' read -r MAJOR MINOR PATCH <<< "${{ steps.fork_state.outputs.current_version }}"
+          IFS='.' read -r MAJOR MINOR PATCH <<< "${{ inputs.current_version }}"
           PATCH=$(($PATCH + 1))
           NEW_VERSION="$MAJOR.$MINOR.$PATCH"
-          sed -i "0,/${{ steps.fork_state.outputs.current_version }}/s//${NEW_VERSION}/" ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }}
-          sed -i "0,/${{ steps.fork_state.outputs.current_version }}/s//${NEW_VERSION}/" ${{ env.PYPROJECT_FILE }}
+          sed -i "0,/${{ inputs.current_version }}/s//${NEW_VERSION}/" ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }}
+          sed -i "0,/${{ inputs.current_version }}/s//${NEW_VERSION}/" ${{ env.PYPROJECT_FILE }}
           git add ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }} ${{ env.PYPROJECT_FILE }}
-          if git status --porcelain | grep -q -E "${{ env.VERSION_FILE }}|${{ env.SETUP_FILE }}|${{ env.PYPROJECT_FILE }}"; then
-            git commit -m "Auto-increment version to $NEW_VERSION"
-          fi
+          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
 
       - name: Install uv
         uses: astral-sh/setup-uv@v5
@@ -69,7 +61,7 @@ jobs:
 
       - name: Download license data
         if: steps.license-cache.outputs.cache-hit != 'true'
-        run: uv run .scripts/download_license_data.py
+        run: uv run .scripts/download_license_data.py ${{ env.SPDX_DATA_URL }}
 
       - name: Cache license data
         if: steps.license-cache.outputs.cache-hit != 'true'
@@ -86,29 +78,27 @@ jobs:
           uv run .scripts/update_packaging.py "${{ env.SETUP_FILE }}" "${{ env.AUTHORS_FILE }}" "${{ env.PYPROJECT_FILE }}" "${{ env.LICENSE_DATA }}"
           uvx ruff format
           git add "${{ env.SETUP_FILE }}" "${{ env.PYPROJECT_FILE }}"
-          if git status --porcelain | grep -q -E "${{ env.SETUP_FILE }}|${{ env.PYPROJECT_FILE }}"; then
-            git commit -m "Update supported Python versions"
-          fi
+
       - name: Remove license data
-        run: rm ${{ env.LICENSE_DATA }}
+        run: |
+          if [ -f "${{ env.LICENSE_DATA }}" ]; then
+            rm "${{ env.LICENSE_DATA }}"
+          fi
 
       - name: Update README
         run: |
           uv run .scripts/update_readme.py "${{ env.README_FILE }}"
           git add "${{ env.README_FILE }}"
-          if git status --porcelain | grep -q "README.md"; then
-            git commit -m "Update README"
-          fi
 
       - name: Push changes
         run: |
-          if git log origin/master..HEAD | grep -q .; then
+          if git status --porcelain "${{ env.VERSION_FILE }}" "${{ env.SETUP_FILE }}" "${{ env.PYPROJECT_FILE }}" | grep -q .; then
+            git commit  -m "Auto-increment version to ${{ steps.version.outputs.new_version }}"
             git push origin master
           else
             echo "No changes to push"
           fi
 
-
       - name: Build and publish
         run: |
           uv build

File changed: .scripts/download_license_data.py
@@ -9,8 +9,6 @@ from pathlib import Path
 
 import requests
 
-URL = "https://raw.githubusercontent.com/spdx/license-list-data/refs/heads/main/json/licenses.json"
-
 
 def download_file(url: str) -> dict:
     """Download file at url"""
@@ -32,9 +30,9 @@ def fetch_data(url: str, retry: int = 0) -> dict:
         return fetch_data(url, retry)
 
 
-def main() -> None:
+def main(url: str) -> None:
     file = Path(__file__).parent / "license-data.json"
-    data = fetch_data(URL)
+    data = fetch_data(url)
     print(f"Downloaded {len(data)} licenses")
     with file.open("w", encoding="utf-8") as f:
         json.dump(data, f)
@@ -45,4 +43,5 @@ def main() -> None:
 
 
 if __name__ == "__main__":
-    main()
+    url = sys.argv[1]
+    main(url)

File changed: .scripts/update_packaging.py
@@ -135,12 +135,8 @@ def update_urls(proj_urls: Table, home_url: str) -> Table:
     """Create a urls table from new homepage url and other existing urls"""
     urls = tomlkit.table()
     urls.add("Homepage", home_url)
-<<<<<<< HEAD
-=======
     if not proj_urls or proj_urls.value is None:
         return urls
-
->>>>>>> 6dcceb7df8ab3a4504f8c70f7d5ba3d050ff1653
     for page, url in proj_urls.value.body:
         if page != "Homepage":
             urls.add(page, url)

File changed: VERSION.txt
@@ -1 +1 @@
-EbookLib 0.18.2
+EbookLib 0.18.1

File changed: pyproject.toml
@@ -1,6 +1,6 @@
 [project]
 name = "ebooklib-autoupdate"
-version = "0.18.2"
+version = "0.18.1"
 description = "Ebook library which can handle EPUB2/EPUB3 format"
 readme = "README.md"
 requires-python = ">=3.6"

-------------------------

Commit Hash: 0c8f728ff82fb5deefa4a737b3e1ef1ec2cb4ba1
Commit Message: Turn update-files into action
Diff: (4 files changed)
File added: .github/actions/update-files.yml
@@ -0,0 +1,99 @@
+name: Update Files
+description: Update files and increment version
+inputs:
+  current_version:
+    description: Current version
+    required: true   
+
+runs:
+  using: "composite"
+  steps:
+    - name: Checkout
+      uses: actions/checkout@v4
+
+    - name: Set up Git user
+      shell: bash
+      run: |
+        git config --global user.name "github-actions[bot]"
+        git config --global user.email "github-actions[bot]@users.noreply.com"
+
+    - name: Increment version
+      id: version
+      shell: bash
+      run: |
+        IFS='.' read -r MAJOR MINOR PATCH <<< "${{ inputs.current_version }}"
+        PATCH=$(($PATCH + 1))
+        NEW_VERSION="$MAJOR.$MINOR.$PATCH"
+        sed -i "0,/${{ inputs.current_version }}/s//${NEW_VERSION}/" ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }}
+        sed -i "0,/${{ inputs.current_version }}/s//${NEW_VERSION}/" ${{ env.PYPROJECT_FILE }}
+        git add ${{ env.VERSION_FILE }} ${{ env.SETUP_FILE }} ${{ env.PYPROJECT_FILE }}
+        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
+
+    - name: Install uv
+      uses: astral-sh/setup-uv@v5
+      with:
+        enable-cache: true
+
+    - name: "Set up Python"
+      uses: actions/setup-python@v5
+      with:
+        python-version: "3.13"
+
+    - name: Restore license data from cache
+      id: license-cache
+      uses: actions/cache@v4
+      with:
+        path: ./.scripts/license-data.json
+        key: license-data
+
+    - name: Download license data
+      if: steps.license-cache.outputs.cache-hit != 'true'
+      shell: bash
+      run: uv run .scripts/download_license_data.py ${{ env.SPDX_DATA_URL }}
+
+    - name: Cache license data
+      if: steps.license-cache.outputs.cache-hit != 'true'
+      uses: actions/cache@v4
+      with:
+        path: ./.scripts/license-data.json
+        key: license-data
+
+    - name: Add license data to env
+      shell: bash
+      run: echo "LICENSE_DATA=$(pwd)/.scripts/license-data.json" >> $GITHUB_ENV
+
+    - name: Update packaging
+      shell: bash
+      run: |
+        uv run .scripts/update_packaging.py "${{ env.SETUP_FILE }}" "${{ env.AUTHORS_FILE }}" "${{ env.PYPROJECT_FILE }}" "${{ env.LICENSE_DATA }}"
+        uvx ruff format
+        git add "${{ env.SETUP_FILE }}" "${{ env.PYPROJECT_FILE }}"
+
+    - name: Remove license data
+      shell: bash
+      run: |
+        if [ -f "${{ env.LICENSE_DATA }}" ]; then
+          rm "${{ env.LICENSE_DATA }}"
+        fi
+
+    - name: Update README
+      shell: bash
+      run: |
+        uv run .scripts/update_readme.py "${{ env.README_FILE }}"
+        git add "${{ env.README_FILE }}"
+
+    - name: Push changes
+      shell: bash
+      run: |
+        if git status --porcelain "${{ env.VERSION_FILE }}" "${{ env.SETUP_FILE }}" "${{ env.PYPROJECT_FILE }}" | grep -q .; then
+          git commit  -m "Auto-increment version to ${{ steps.version.outputs.new_version }}"
+          git push origin master
+        else
+          echo "No changes to push"
+        fi
+
+    - name: Build and publish
+      shell: bash
+      run: |
+        uv build
+        uv publish

File changed: .github/workflows/auto-update.yml
@@ -10,6 +10,12 @@ permissions:
 
 env:
   VERSION_FILE: VERSION.txt
+  SETUP_FILE: setup.py
+  AUTHORS_FILE: AUTHORS.txt
+  PYPROJECT_FILE: pyproject.toml
+  README_FILE: README.md
+  SPDX_DATA_URL: https://raw.githubusercontent.com/spdx/license-list-data/refs/heads/main/json/licenses.json
+
 
 jobs:
   update:

File changed: .github/workflows/local-sync.yml
@@ -12,6 +12,12 @@ permissions:
 
 env:
   VERSION_FILE: VERSION.txt
+  SETUP_FILE: setup.py
+  AUTHORS_FILE: AUTHORS.txt
+  PYPROJECT_FILE: pyproject.toml
+  README_FILE: README.md
+  SPDX_DATA_URL: https://raw.githubusercontent.com/spdx/license-list-data/refs/heads/main/json/licenses.json
+
 
 jobs:
   update:
@@ -29,7 +35,7 @@ jobs:
           echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          
       - name: Update files
-        uses: ./.github/workflows/update-files.yml
+        uses: ./.github/actions/update-files.yml
         with:
           current_version: ${{ steps.version.outputs.current_version }}
 

.github/workflows/update-files.yml deleted
-------------------------

Commit Hash: f2f042550d2cef4a17f3bec328c74068c8294688
Commit Message: Fix action format
Diff: (3 files changed)

File changed: .github/workflows/auto-update.yml
@@ -62,7 +62,7 @@ jobs:
 
       - name: Update files
         if: steps.upstream_changes.outputs.updated_version == 'true'
-        uses: ./.github/workflows/update-files.yml
+        uses: ./.github/actions/update-files
         with:
           current_version: ${{ steps.fork_state.outputs.current_version }}
           

File changed: .github/workflows/local-sync.yml
@@ -35,7 +35,7 @@ jobs:
           echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          
       - name: Update files
-        uses: ./.github/actions/update-files.yml
+        uses: ./.github/actions/update-files
         with:
           current_version: ${{ steps.version.outputs.current_version }}
 

-------------------------

Commit Hash: f9c348ab22cde2a6b37bd86ac6cc2a74db0fe288
Commit Message: import sys
Diff: (1 files changed)
File changed: .scripts/download_license_data.py
@@ -5,6 +5,7 @@
 # ///
 import time
 import json
+import sys
 from pathlib import Path
 
 import requests

-------------------------

Commit Hash: 7c303ef9c2ef402315df5fb2270bbed107a923b9
Commit Message: Auto-increment version to 0.18.2
Diff: (2 files changed)
File changed: VERSION.txt
@@ -1 +1 @@
-EbookLib 0.18.1
+EbookLib 0.18.2

File changed: pyproject.toml
@@ -1,6 +1,6 @@
 [project]
 name = "ebooklib-autoupdate"
-version = "0.18.1"
+version = "0.18.2"
 description = "Ebook library which can handle EPUB2/EPUB3 format"
 readme = "README.md"
 requires-python = ">=3.6"

-------------------------

Commit Hash: f45ceabb9af28b83277088a67e47fce678fdf92f
Commit Message: Rollback auto-increment on publish fail
Diff: (2 files changed)
File changed: VERSION.txt
@@ -1 +1 @@
-EbookLib 0.18.2
+EbookLib 0.18.1

File changed: pyproject.toml
@@ -1,6 +1,6 @@
 [project]
 name = "ebooklib-autoupdate"
-version = "0.18.2"
+version = "0.18.1"
 description = "Ebook library which can handle EPUB2/EPUB3 format"
 readme = "README.md"
 requires-python = ">=3.6"

-------------------------

Commit Hash: bbbc95c8bbabe8cfc26c01107fa7e199cfdd6e8a
Commit Message: Auto-increment version to 0.18.2
Diff: (2 files changed)
File changed: VERSION.txt
@@ -1 +1 @@
-EbookLib 0.18.1
+EbookLib 0.18.2

File changed: pyproject.toml
@@ -1,6 +1,6 @@
 [project]
 name = "ebooklib-autoupdate"
-version = "0.18.1"
+version = "0.18.2"
 description = "Ebook library which can handle EPUB2/EPUB3 format"
 readme = "README.md"
 requires-python = ">=3.6"

-------------------------